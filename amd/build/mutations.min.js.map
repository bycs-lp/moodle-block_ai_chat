{"version":3,"file":"mutations.min.js","sources":["../src/mutations.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport {callExternalFunctionReactiveUpdate} from 'block_ai_chat/utils';\n\n/**\n * Mutations for the AI Chat block.\n *\n * @module     block_ai_chat/mutations\n * @copyright  2025 ISB Bayern\n * @author     Philipp Memmel\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nexport default class {\n\n    async selectCurrentPersona(stateManager, personaid) {\n        let ajaxresult = await callExternalFunctionReactiveUpdate('block_ai_chat_select_persona',\n            {\n                contextid: stateManager.state.static.contextid,\n                personaid,\n            }\n        );\n        if (ajaxresult === null) {\n            return;\n        }\n        stateManager.processUpdates(ajaxresult);\n    }\n\n    async selectCurrentPersonaAndLoadChat(stateManager, personaid) {\n        await this.selectCurrentPersona(stateManager, personaid);\n        await this.setView(stateManager, 'chat');\n    }\n\n    async submitAiRequest(stateManager, prompt) {\n        this.setLoadingState(stateManager, true);\n        const options = {\n            conversationid: stateManager.state.config.currentConversationId,\n        };\n        const requestOptions = JSON.stringify(options);\n        const result = await callExternalFunctionReactiveUpdate('block_ai_chat_request_ai',\n            {\n                contextid: stateManager.state.static.contextid,\n                prompt: prompt,\n                options: requestOptions\n            }\n        );\n        if (result === null) {\n            this.setLoadingState(stateManager, false);\n            return;\n        }\n        this.setLoadingState(stateManager, false);\n        stateManager.processUpdates(result);\n        if (stateManager.state.config.currentConversationId === 0) {\n            // If this is the first message in a conversation, the conversation id is still 0.\n            // After first message we have to fix that in our local state.\n            stateManager.setReadOnly(false);\n            stateManager.state.config.currentConversationId = stateManager.state.messages.values().next().value.conversationid;\n            stateManager.setReadOnly(true);\n        }\n    }\n\n    setLoadingState(stateManager, isLoading) {\n        stateManager.setReadOnly(false);\n        stateManager.state.config.loadingState = isLoading;\n        stateManager.setReadOnly(true);\n    }\n\n    async setCurrentConversation(stateManager, conversationid) {\n        stateManager.setReadOnly(false);\n        stateManager.state.config.currentConversationId = conversationid;\n        stateManager.setReadOnly(true);\n    }\n\n    setView(stateManager, view) {\n        if (stateManager.state.config.view === view) {\n            return;\n        }\n        stateManager.setReadOnly(false);\n        stateManager.state.config.view = view;\n        stateManager.setReadOnly(true);\n    }\n\n    async createAndViewNewConversation(stateManager) {\n        await this.setConversationAndLoadChat(stateManager, 0);\n    }\n\n    async setConversationAndLoadChat(stateManager, conversationid) {\n        await this.setCurrentConversation(stateManager, conversationid);\n        stateManager.setReadOnly(false);\n        stateManager.state.config.view = 'dummy';\n        stateManager.setReadOnly(true);\n        stateManager.setReadOnly(false);\n        stateManager.state.config.view = 'chat';\n        stateManager.setReadOnly(true);\n    }\n\n    async loadCurrentConversationMessages(stateManager) {\n        let deleteActions = [];\n\n        // There probably isn't a better way to remove all messages while triggering all\n        // necessary state updates.\n        stateManager.state.messages.forEach(message => {\n            deleteActions.push(\n                {\n                    \"name\": \"messages\",\n                    \"action\": \"remove\",\n                    \"fields\":\n                        {\n                            \"id\": message.id\n                        }\n                });\n        });\n        stateManager.processUpdates(deleteActions);\n\n        if (stateManager.state.config.currentConversationId === 0) {\n            return;\n        }\n        const messages = await callExternalFunctionReactiveUpdate(\n            'block_ai_chat_get_messages',\n            {\n                contextid: stateManager.state.static.contextid,\n                conversationid: stateManager.state.config.currentConversationId\n            }\n        );\n        if (messages === null) {\n            return;\n        }\n        stateManager.processUpdates(messages);\n    }\n\n    markPersona(stateManager, personaId) {\n        stateManager.setReadOnly(false);\n        stateManager.state.config.currentlyMarkedPersona = personaId;\n        stateManager.setReadOnly(true);\n    }\n\n    async createNewDummyPersona(stateManager) {\n        let ajaxresult = await callExternalFunctionReactiveUpdate(\n            'block_ai_chat_create_dummy_persona',\n            {\n                contextid: stateManager.state.static.contextid,\n            }\n        );\n        if (ajaxresult === null) {\n            return;\n        }\n        stateManager.processUpdates(ajaxresult);\n    }\n\n    async duplicatePersona(stateManager, personaid) {\n        let ajaxresult = await callExternalFunctionReactiveUpdate(\n            'block_ai_chat_duplicate_persona',\n            {\n                contextid: stateManager.state.static.contextid,\n                personaid\n            }\n        );\n        if (ajaxresult === null) {\n            return;\n        }\n        stateManager.processUpdates(ajaxresult);\n    }\n\n    async deletePersona(stateManager, personaid) {\n        let ajaxresult = await callExternalFunctionReactiveUpdate(\n            'block_ai_chat_delete_persona',\n            {\n                contextid: stateManager.state.static.contextid,\n                personaid,\n            }\n        );\n        if (ajaxresult === null) {\n            return;\n        }\n        stateManager.processUpdates(ajaxresult);\n    }\n\n    processDynamicFormUpdates(stateManager, stateUpdates) {\n        stateUpdates.map(update => {\n            if (typeof update.fields !== 'object') {\n                update.fields = JSON.parse(update.fields);\n            }\n            return update;\n        });\n        stateManager.processUpdates(stateUpdates);\n    }\n\n    async deleteCurrentConversation(stateManager) {\n        let ajaxresult = await callExternalFunctionReactiveUpdate(\n            'block_ai_chat_delete_conversation',\n            {\n                contextid: stateManager.state.static.contextid,\n                conversationid: stateManager.state.config.currentConversationId\n            }\n        );\n        if (ajaxresult === null) {\n            return;\n        }\n        // We intentionally do not process the updates, because we currently are removing messages anyway\n        // before reloading when (re)loading the chat component.\n        await this.createAndViewNewConversation(stateManager);\n    }\n\n    setWindowMode(stateManager, windowmode) {\n        stateManager.setReadOnly(false);\n        stateManager.state.config.windowMode = windowmode;\n        stateManager.setReadOnly(true);\n    }\n\n    setModalVisibility(stateManager, visible = null) {\n        stateManager.setReadOnly(false);\n        stateManager.state.config.modalVisible = visible === null ? !stateManager.state.config.modalVisible : visible;\n        stateManager.setReadOnly(true);\n    }\n}\n"],"names":["stateManager","personaid","ajaxresult","contextid","state","static","processUpdates","this","selectCurrentPersona","setView","prompt","setLoadingState","options","conversationid","config","currentConversationId","requestOptions","JSON","stringify","result","setReadOnly","messages","values","next","value","isLoading","loadingState","view","setConversationAndLoadChat","setCurrentConversation","deleteActions","forEach","message","push","id","markPersona","personaId","currentlyMarkedPersona","processDynamicFormUpdates","stateUpdates","map","update","fields","parse","createAndViewNewConversation","setWindowMode","windowmode","windowMode","setModalVisibility","visible","modalVisible"],"mappings":"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"}