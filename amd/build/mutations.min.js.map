{"version":3,"file":"mutations.min.js","sources":["../src/mutations.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport {callExternalFunctionReactiveUpdate} from 'block_ai_chat/utils';\n\n/**\n * Mutations for the AI Chat block.\n *\n * @module     block_ai_chat/mutations\n * @copyright  2025 ISB Bayern\n * @author     Philipp Memmel\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nexport default class {\n\n    async selectCurrentPersona(stateManager, personaid) {\n        let ajaxresult = await callExternalFunctionReactiveUpdate('block_ai_chat_select_persona',\n            {\n                contextid: stateManager.state.static.contextid,\n                component: stateManager.state.static.component,\n                personaid,\n            }\n        );\n        if (ajaxresult === null) {\n            return;\n        }\n        stateManager.processUpdates(ajaxresult);\n    }\n\n    async selectCurrentPersonaAndLoadChat(stateManager, personaid) {\n        await this.selectCurrentPersona(stateManager, personaid);\n        await this.setView(stateManager, 'chat');\n    }\n\n    async submitAiRequest(stateManager, prompt, additionalOptions) {\n        this.setLoadingState(stateManager, true);\n        const options = {\n            conversationid: stateManager.state.config.currentConversationId,\n            ...additionalOptions\n        };\n\n        const requestOptions = JSON.stringify(options);\n        const result = await callExternalFunctionReactiveUpdate('block_ai_chat_request_ai',\n            {\n                contextid: stateManager.state.static.contextid,\n                component: stateManager.state.static.component,\n                mode: stateManager.state.config.mode,\n                prompt: prompt,\n                options: requestOptions\n            }\n        );\n        if (result === null) {\n            this.setLoadingState(stateManager, false);\n            return;\n        }\n        this.setLoadingState(stateManager, false);\n        stateManager.processUpdates(result);\n        if (stateManager.state.config.currentConversationId === 0) {\n            // If this is the first message in a conversation, the conversation id is still 0.\n            // After first message we have to fix that in our local state.\n            stateManager.setReadOnly(false);\n            stateManager.state.config.currentConversationId = stateManager.state.messages.values().next().value.conversationid;\n            stateManager.setReadOnly(true);\n        }\n    }\n\n    setLoadingState(stateManager, isLoading) {\n        stateManager.setReadOnly(false);\n        stateManager.state.config.loadingState = isLoading;\n        stateManager.setReadOnly(true);\n    }\n\n    async setCurrentConversation(stateManager, conversationid) {\n        stateManager.setReadOnly(false);\n        stateManager.state.config.currentConversationId = conversationid;\n        stateManager.setReadOnly(true);\n    }\n\n    setView(stateManager, view) {\n        if (stateManager.state.config.view === view) {\n            return;\n        }\n        stateManager.setReadOnly(false);\n        stateManager.state.config.view = view;\n        stateManager.setReadOnly(true);\n    }\n\n    async createAndViewNewConversation(stateManager) {\n        await this.setConversationAndLoadChat(stateManager, 0);\n    }\n\n    async setConversationAndLoadChat(stateManager, conversationid) {\n        await this.setCurrentConversation(stateManager, conversationid);\n        stateManager.setReadOnly(false);\n        stateManager.state.config.view = 'dummy';\n        stateManager.setReadOnly(true);\n        stateManager.setReadOnly(false);\n        stateManager.state.config.view = 'chat';\n        stateManager.setReadOnly(true);\n    }\n\n    async loadCurrentConversationMessages(stateManager) {\n        let deleteActions = [];\n\n        // There probably isn't a better way to remove all messages while triggering all\n        // necessary state updates.\n        stateManager.state.messages.forEach(message => {\n            deleteActions.push(\n                {\n                    \"name\": \"messages\",\n                    \"action\": \"remove\",\n                    \"fields\":\n                        {\n                            \"id\": message.id\n                        }\n                });\n        });\n        stateManager.processUpdates(deleteActions);\n\n        if (stateManager.state.config.currentConversationId === 0) {\n            return;\n        }\n        const messages = await callExternalFunctionReactiveUpdate(\n            'block_ai_chat_get_messages',\n            {\n                contextid: stateManager.state.static.contextid,\n                component: stateManager.state.static.component,\n                conversationid: stateManager.state.config.currentConversationId\n            }\n        );\n        if (messages === null) {\n            return;\n        }\n        stateManager.processUpdates(messages);\n    }\n\n    markPersona(stateManager, personaId) {\n        stateManager.setReadOnly(false);\n        stateManager.state.config.currentlyMarkedPersona = personaId;\n        stateManager.setReadOnly(true);\n    }\n\n    async createNewDummyPersona(stateManager) {\n        let ajaxresult = await callExternalFunctionReactiveUpdate(\n            'block_ai_chat_create_dummy_persona',\n            {\n                contextid: stateManager.state.static.contextid,\n                component: stateManager.state.static.component\n            }\n        );\n        if (ajaxresult === null) {\n            return;\n        }\n        stateManager.processUpdates(ajaxresult);\n    }\n\n    async duplicatePersona(stateManager, personaid) {\n        let ajaxresult = await callExternalFunctionReactiveUpdate(\n            'block_ai_chat_duplicate_persona',\n            {\n                contextid: stateManager.state.static.contextid,\n                component: stateManager.state.static.component,\n                personaid\n            }\n        );\n        if (ajaxresult === null) {\n            return;\n        }\n        stateManager.processUpdates(ajaxresult);\n    }\n\n    async deletePersona(stateManager, personaid) {\n        let ajaxresult = await callExternalFunctionReactiveUpdate(\n            'block_ai_chat_delete_persona',\n            {\n                contextid: stateManager.state.static.contextid,\n                component: stateManager.state.static.component,\n                personaid,\n            }\n        );\n        if (ajaxresult === null) {\n            return;\n        }\n        stateManager.processUpdates(ajaxresult);\n    }\n\n    processDynamicFormUpdates(stateManager, stateUpdates) {\n        stateUpdates.map(update => {\n            if (typeof update.fields !== 'object') {\n                update.fields = JSON.parse(update.fields);\n            }\n            return update;\n        });\n        stateManager.processUpdates(stateUpdates);\n    }\n\n    async deleteCurrentConversation(stateManager) {\n        let ajaxresult = await callExternalFunctionReactiveUpdate(\n            'block_ai_chat_delete_conversation',\n            {\n                contextid: stateManager.state.static.contextid,\n                component: stateManager.state.static.component,\n                conversationid: stateManager.state.config.currentConversationId\n            }\n        );\n        if (ajaxresult === null) {\n            return;\n        }\n        // We intentionally do not process the updates, because we currently are removing messages anyway\n        // before reloading when (re)loading the chat component.\n        await this.createAndViewNewConversation(stateManager);\n    }\n\n    setWindowMode(stateManager, windowmode) {\n        stateManager.setReadOnly(false);\n        stateManager.state.config.windowMode = windowmode;\n        stateManager.setReadOnly(true);\n    }\n\n    setModalVisibility(stateManager, visible = null) {\n        stateManager.setReadOnly(false);\n        stateManager.state.config.modalVisible = visible === null ? !stateManager.state.config.modalVisible : visible;\n        stateManager.setReadOnly(true);\n    }\n\n    setMode(stateManager, mode) {\n        stateManager.setReadOnly(false);\n        stateManager.state.config.mode = mode;\n        stateManager.setReadOnly(true);\n    }\n\n    /**\n     * When inserting a message, we need to set its rendered state after it has been added to the DOM.\n     * This is being done by this mutation which needs to be called from the component after rendering.\n     *\n     * @param {Object} stateManager the state manager\n     * @param {int} messageid the id of the message that has been rendered\n     */\n    setMessageRendered(stateManager, messageid) {\n        stateManager.setReadOnly(false);\n        const message = stateManager.state.messages.get(messageid);\n        if (message) {\n            message.rendered = true;\n            stateManager.state.messages.set(messageid, message);\n        }\n        stateManager.setReadOnly(true);\n    }\n}\n"],"names":["stateManager","personaid","ajaxresult","contextid","state","static","component","processUpdates","this","selectCurrentPersona","setView","prompt","additionalOptions","setLoadingState","options","conversationid","config","currentConversationId","requestOptions","JSON","stringify","result","mode","setReadOnly","messages","values","next","value","isLoading","loadingState","view","setConversationAndLoadChat","setCurrentConversation","deleteActions","forEach","message","push","id","markPersona","personaId","currentlyMarkedPersona","processDynamicFormUpdates","stateUpdates","map","update","fields","parse","createAndViewNewConversation","setWindowMode","windowmode","windowMode","setModalVisibility","visible","modalVisible","setMode","setMessageRendered","messageid","get","rendered","set"],"mappings":"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"}