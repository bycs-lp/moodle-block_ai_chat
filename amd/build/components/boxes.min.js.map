{"version":3,"file":"boxes.min.js","sources":["../../src/components/boxes.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport {BaseComponent} from 'core/reactive';\nimport {renderInfoBox} from 'local_ai_manager/infobox';\nimport {renderWarningBox} from 'local_ai_manager/warningbox';\nimport {eventTypes} from 'block_ai_chat/events';\n\n/**\n * Component representing a message in the ai_chat.\n */\nclass Boxes extends BaseComponent {\n\n    /**\n     * Function to initialize component, called by mustache template.\n     *\n     * @param {*} target The id of the HTMLElement to attach to\n     * @returns {BaseComponent} New component attached to the HTMLElement represented by target\n     */\n    static init(target) {\n        let element = document.querySelector(target);\n        return new this({\n            element: element,\n        });\n    }\n\n    create() {\n        this.name = 'userquota';\n        this.selectors = {\n            INFOBOX: `[data-block_ai_chat-element='ai_manager-infobox']`,\n            WARNINGBOX: `[data-block_ai_chat-element='ai_manager-warningbox']`,\n            CHAT_OUTPUT_WRAPPER: `[data-block_ai_chat-element='outputwrapper']`,\n        };\n        this.HIDE_CLASS = 'block_ai_chat-scroll-hide';\n        this._scrollListenerAttached = false;\n        window.console.log('[Boxes] create() called');\n    }\n\n    getWatchers() {\n        return [\n            {watch: `config.view:updated`, handler: this._showOrHideBoxes},\n            {watch: `config.currentConversationId:updated`, handler: this._onConversationChanged},\n        ];\n    }\n\n    async stateReady() {\n        window.console.log('[Boxes] stateReady() called');\n        await this._renderBoxes();\n        this._showOrHideBoxes();\n\n        // Find the modal container and listen for chatContentRendered events.\n        const modal = this.element.closest('.block_ai_chat_reactive_main_component');\n        if (modal) {\n            this.addEventListener(modal, eventTypes.chatContentRendered, () => this._onChatContentRendered());\n        }\n    }\n\n    /**\n     * Called when chat content has been rendered.\n     * Now we can safely attach the scroll listener to the correct element.\n     */\n    _onChatContentRendered() {\n        window.console.log('[Boxes] Chat content rendered event received');\n        // Reset the flag so we can attach to the new element.\n        this._scrollListenerAttached = false;\n        this._attachScrollListener();\n    }\n\n    /**\n     * Attach scroll listener to the chat output container.\n     * The warning will hide when the user scrolls in the chat.\n     */\n    _attachScrollListener() {\n        if (this._scrollListenerAttached) {\n            window.console.log('[Boxes] Scroll listener already attached, skipping');\n            return;\n        }\n\n        // Find the modal container (boxes is in header, chat output is in body).\n        const modal = this.element.closest('.block_ai_chat_reactive_main_component');\n        if (!modal) {\n            window.console.log('[Boxes] Could not find modal container');\n            return;\n        }\n\n        const chatOutputWrapper = modal.querySelector(this.selectors.CHAT_OUTPUT_WRAPPER);\n        if (chatOutputWrapper) {\n            this._attachScrollListenerToElement(chatOutputWrapper);\n            return;\n        }\n\n        // Chat output not available yet - will be handled by chatContentRendered event.\n        window.console.log('[Boxes] Chat output not rendered yet, waiting for chatContentRendered event');\n    }\n\n    /**\n     * Attach the scroll listener to the given element.\n     *\n     * @param {HTMLElement} chatOutputWrapper The chat output wrapper element\n     */\n    _attachScrollListenerToElement(chatOutputWrapper) {\n        if (this._scrollListenerAttached) {\n            return;\n        }\n        window.console.log('[Boxes] Attaching scroll listener to:', chatOutputWrapper);\n\n        // Store initial scroll position to detect user-initiated scrolls.\n        // Use a small delay to let initial layout/auto-scroll settle.\n        this._ignoreScrollEvents = true;\n        setTimeout(() => {\n            this._ignoreScrollEvents = false;\n            this._lastScrollTop = chatOutputWrapper.scrollTop;\n            window.console.log('[Boxes] Scroll detection enabled, initial scrollTop:', this._lastScrollTop);\n        }, 500);\n\n        this.addEventListener(chatOutputWrapper, 'scroll', () => this._onScroll(chatOutputWrapper));\n        this._scrollListenerAttached = true;\n    }\n\n    /**\n     * Handle scroll event - hide the boxes when user actively scrolls.\n     * Only triggers when there is a visible scrollbar and user scrolls away from bottom.\n     *\n     * @param {HTMLElement} chatOutputWrapper The chat output wrapper container\n     */\n    _onScroll(chatOutputWrapper) {\n        // Ignore scroll events during initial layout/auto-scroll period.\n        if (this._ignoreScrollEvents) {\n            window.console.log('[Boxes] Ignoring scroll event during initial layout');\n            return;\n        }\n\n        // Check if scrollbar is actually visible (content overflows the container).\n        const hasVisibleScrollbar = chatOutputWrapper.scrollHeight > chatOutputWrapper.clientHeight;\n\n        // Check if we're at the bottom (auto-scroll position) or user scrolled away.\n        // Auto-scroll always goes to bottom, so if user is NOT at bottom, they scrolled.\n        const distanceFromBottom = chatOutputWrapper.scrollHeight - chatOutputWrapper.scrollTop - chatOutputWrapper.clientHeight;\n        const isAtBottom = distanceFromBottom < 10; // Allow small tolerance\n\n        window.console.log('[Boxes] Scroll event fired!', {\n            scrollTop: chatOutputWrapper.scrollTop,\n            scrollHeight: chatOutputWrapper.scrollHeight,\n            clientHeight: chatOutputWrapper.clientHeight,\n            distanceFromBottom: distanceFromBottom,\n            isAtBottom: isAtBottom,\n            hasVisibleScrollbar: hasVisibleScrollbar\n        });\n\n        // Only hide if there's a visible scrollbar AND user scrolled away from bottom.\n        // This ensures we don't trigger on auto-scroll (which always goes to bottom).\n        if (hasVisibleScrollbar && !isAtBottom) {\n            window.console.log('[Boxes] Hiding boxes - user scrolled away from bottom');\n            this.element.classList.add(this.HIDE_CLASS);\n        }\n    }\n\n    async _renderBoxes() {\n        await renderInfoBox(\n            'block_ai_chat',\n            this.reactive.state.config.userid,\n            this.getElement(this.selectors.INFOBOX),\n            ['chat']\n        );\n        // Show AI info warning.\n        await renderWarningBox(this.getElement(this.selectors.WARNINGBOX));\n    }\n\n    _showOrHideBoxes() {\n        if (this.reactive.state.config.view === 'chat') {\n            // Reset visibility and remove hide animation class.\n            this.element.classList.remove('d-none', this.HIDE_CLASS);\n            // Reset scroll listener so it can fire again when view changes.\n            this._scrollListenerAttached = false;\n            this._attachScrollListener();\n        } else {\n            this.element.classList.add('d-none');\n        }\n    }\n\n    /**\n     * Called when the conversation changes (new chat created or old chat selected).\n     * Resets the boxes visibility and reattaches the scroll listener.\n     */\n    _onConversationChanged() {\n        window.console.log('[Boxes] Conversation changed, resetting boxes', {\n            view: this.reactive.state.config.view,\n            conversationId: this.reactive.state.config.currentConversationId,\n            scrollListenerAttached: this._scrollListenerAttached\n        });\n        // Only reset if we're in chat view.\n        if (this.reactive.state.config.view === 'chat') {\n            // Show boxes again.\n            this.element.classList.remove(this.HIDE_CLASS);\n            // Reset scroll listener so it can fire again for the new conversation.\n            this._scrollListenerAttached = false;\n            this._attachScrollListener();\n        }\n    }\n}\n\nexport default Boxes;\n"],"names":["Boxes","BaseComponent","target","this","element","document","querySelector","create","name","selectors","INFOBOX","WARNINGBOX","CHAT_OUTPUT_WRAPPER","HIDE_CLASS","_scrollListenerAttached","window","console","log","getWatchers","watch","handler","_showOrHideBoxes","_onConversationChanged","_renderBoxes","modal","closest","addEventListener","eventTypes","chatContentRendered","_onChatContentRendered","_attachScrollListener","chatOutputWrapper","_attachScrollListenerToElement","_ignoreScrollEvents","setTimeout","_lastScrollTop","scrollTop","_onScroll","hasVisibleScrollbar","scrollHeight","clientHeight","distanceFromBottom","isAtBottom","classList","add","reactive","state","config","userid","getElement","view","remove","conversationId","currentConversationId","scrollListenerAttached"],"mappings":"qSAuBMA,cAAcC,oCAQJC,eAED,IAAIC,KAAK,CACZC,QAFUC,SAASC,cAAcJ,UAMzCK,cACSC,KAAO,iBACPC,UAAY,CACbC,4DACAC,kEACAC,yEAECC,WAAa,iCACbC,yBAA0B,EAC/BC,OAAOC,QAAQC,IAAI,2BAGvBC,oBACW,CACH,CAACC,4BAA8BC,QAASjB,KAAKkB,kBAC7C,CAACF,6CAA+CC,QAASjB,KAAKmB,4CAKlEP,OAAOC,QAAQC,IAAI,qCACbd,KAAKoB,oBACNF,yBAGCG,MAAQrB,KAAKC,QAAQqB,QAAQ,0CAC/BD,YACKE,iBAAiBF,MAAOG,mBAAWC,qBAAqB,IAAMzB,KAAK0B,2BAQhFA,yBACId,OAAOC,QAAQC,IAAI,qDAEdH,yBAA0B,OAC1BgB,wBAOTA,2BACQ3B,KAAKW,oCACLC,OAAOC,QAAQC,IAAI,4DAKjBO,MAAQrB,KAAKC,QAAQqB,QAAQ,8CAC9BD,kBACDT,OAAOC,QAAQC,IAAI,gDAIjBc,kBAAoBP,MAAMlB,cAAcH,KAAKM,UAAUG,qBACzDmB,uBACKC,+BAA+BD,mBAKxChB,OAAOC,QAAQC,IAAI,+EAQvBe,+BAA+BD,mBACvB5B,KAAKW,0BAGTC,OAAOC,QAAQC,IAAI,wCAAyCc,wBAIvDE,qBAAsB,EAC3BC,YAAW,UACFD,qBAAsB,OACtBE,eAAiBJ,kBAAkBK,UACxCrB,OAAOC,QAAQC,IAAI,uDAAwDd,KAAKgC,kBACjF,UAEET,iBAAiBK,kBAAmB,UAAU,IAAM5B,KAAKkC,UAAUN,0BACnEjB,yBAA0B,GASnCuB,UAAUN,sBAEF5B,KAAK8B,gCACLlB,OAAOC,QAAQC,IAAI,6DAKjBqB,oBAAsBP,kBAAkBQ,aAAeR,kBAAkBS,aAIzEC,mBAAqBV,kBAAkBQ,aAAeR,kBAAkBK,UAAYL,kBAAkBS,aACtGE,WAAaD,mBAAqB,GAExC1B,OAAOC,QAAQC,IAAI,8BAA+B,CAC9CmB,UAAWL,kBAAkBK,UAC7BG,aAAcR,kBAAkBQ,aAChCC,aAAcT,kBAAkBS,aAChCC,mBAAoBA,mBACpBC,WAAYA,WACZJ,oBAAqBA,sBAKrBA,sBAAwBI,aACxB3B,OAAOC,QAAQC,IAAI,8DACdb,QAAQuC,UAAUC,IAAIzC,KAAKU,wCAK9B,0BACF,gBACAV,KAAK0C,SAASC,MAAMC,OAAOC,OAC3B7C,KAAK8C,WAAW9C,KAAKM,UAAUC,SAC/B,CAAC,eAGC,gCAAiBP,KAAK8C,WAAW9C,KAAKM,UAAUE,aAG1DU,mBAC4C,SAApClB,KAAK0C,SAASC,MAAMC,OAAOG,WAEtB9C,QAAQuC,UAAUQ,OAAO,SAAUhD,KAAKU,iBAExCC,yBAA0B,OAC1BgB,8BAEA1B,QAAQuC,UAAUC,IAAI,UAQnCtB,yBACIP,OAAOC,QAAQC,IAAI,gDAAiD,CAChEiC,KAAM/C,KAAK0C,SAASC,MAAMC,OAAOG,KACjCE,eAAgBjD,KAAK0C,SAASC,MAAMC,OAAOM,sBAC3CC,uBAAwBnD,KAAKW,0BAGO,SAApCX,KAAK0C,SAASC,MAAMC,OAAOG,YAEtB9C,QAAQuC,UAAUQ,OAAOhD,KAAKU,iBAE9BC,yBAA0B,OAC1BgB,uCAKF9B"}