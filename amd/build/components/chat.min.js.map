{"version":3,"file":"chat.min.js","sources":["../../src/components/chat.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport BaseContent from 'block_ai_chat/components/base_content';\nimport * as TinyAiUtils from 'tiny_ai/utils';\nimport TinyAiEditorUtils from 'tiny_ai/editor_utils';\nimport {constants as TinyAiConstants} from 'tiny_ai/constants';\nimport Templates from 'core/templates';\nimport {getAiConfig} from 'local_ai_manager/config';\nimport {getString} from 'core/str';\nimport {alert as displayAlert} from 'core/notification';\nimport {showErrorToast} from 'block_ai_chat/utils';\nimport {MODES} from 'block_ai_chat/constants';\nimport * as DomExtractor from 'block_ai_chat/dom_extractor';\nimport {notifyMessageRendered, notifyChatContentRendered} from 'block_ai_chat/events';\n\n\nclass Chat extends BaseContent {\n    /**\n     * Function to initialize component, called by mustache template.\n     *\n     * @param {*} target The id of the HTMLElement to attach to\n     * @returns {BaseComponent} New component attached to the HTMLElement represented by target\n     */\n    static init(target) {\n        let element = document.querySelector(target);\n        return new this({\n            element: element,\n        });\n    }\n\n    /**\n     * It is important to follow some conventions while you write components. This way all components\n     * will be implemented in a similar way and anybody will be able to understand how it works.\n     *\n     * All the component definition should be initialized on the \"create\" method.\n     */\n    create() {\n        this.name = 'ChatComponent';\n        this.selectors = {\n            MESSAGES: `[data-block_ai_chat-element='messages']`,\n            INPUT_TEXTAREA: `[data-block_ai_chat-element='inputtextarea']`,\n            SUBMIT_BUTTON: `[data-block_ai_chat-element='submitbutton']`,\n            LOADING_SPINNER_MESSAGE: `[data-block_ai_chat-element='loadingspinner']`,\n            TEMPORARY_PROMPT_MESSAGE: `[data-block_ai_chat-element='temporaryprompt']`,\n            TINY_AI_BUTTON: `[data-block_ai_chat-element='tinyaibutton']`,\n            OUTPUT_WRAPPER: `[data-block_ai_chat-element='outputwrapper']`,\n            CHAT_OUTPUT: `[data-block_ai_chat-element='chatoutput']`,\n            HISTORY_MARKER: `[data-block_ai_chat-element='historymarker']`,\n        };\n    }\n\n    /**\n     * Initial state ready method.\n     *\n     * Initially calls the setView action to set the view to 'chat' once ready to trigger the first\n     * rendering of itself.\n     */\n    async stateReady() {\n        this.reactive.dispatch('setView', 'chat');\n    }\n\n    getWatchers() {\n        return [\n            ...super.getWatchers(),\n            {watch: `messages:created`, handler: this._addMessageToChatArea},\n            {watch: `personas${this.reactive.state.config.currentPersona}:deleted`, handler: this._removeCurrentPersona},\n            {watch: `config.loadingState:updated`, handler: this._handleLoadingStateUpdated},\n        ];\n    }\n\n    async _addMessageToChatArea({element}) {\n        let placeholder = document.createElement('div');\n        placeholder.setAttribute('data-id', element.id);\n        let node = this.getElement(this.selectors.CHAT_OUTPUT);\n        node.appendChild(placeholder);\n\n        const responseIsAgentResponse = element.messageMode === 'agent';\n\n        let templateData = {\n            id: element.id,\n            agentMode: responseIsAgentResponse,\n            senderai: element.sender === 'ai',\n            loading: element.hasOwnProperty('loading') ? element.loading : false,\n        };\n        if (responseIsAgentResponse) {\n            const agentResponse = responseIsAgentResponse ? this._getAgentAnswerTemplateContext(element.content) : {};\n            templateData = {...templateData, ...agentResponse};\n        } else {\n            templateData.content = element.content;\n        }\n        const newcomponent = await this.renderComponent(placeholder, 'block_ai_chat/components/message', templateData);\n        const newelement = newcomponent.getElement();\n        node.replaceChild(newelement, placeholder);\n        notifyMessageRendered({messageId: element.id}, node);\n        this._scrollToBottom();\n        this._focusInputTextarea();\n    }\n\n\n    async _submitAiRequestListener() {\n        const textarea = this.getElement(this.selectors.INPUT_TEXTAREA);\n        const prompt = textarea.value;\n        if (prompt.trim() === '') {\n            const errorString = getString('erroremptyprompt', 'block_ai_chat');\n            await showErrorToast(errorString);\n            return;\n        }\n        const additionalOptions = {};\n        if (this.reactive.state.config.mode === MODES.AGENT) {\n            additionalOptions.agentoptions = {\n                formelements: DomExtractor.extractDomElements(),\n                pageid: document.body.id\n            };\n        }\n        this.reactive.dispatch('submitAiRequest', prompt, additionalOptions);\n    }\n\n    async _handleLoadingStateUpdated({element}) {\n        const loadingSpinnerMessage = {\n            'id': 'loadingspinner',\n            'sender': 'ai',\n            'loading': true,\n            'agentMode': false\n        };\n\n        const temporaryPromptMessage = {\n            'id': 'temporaryprompt',\n            'sender': 'user',\n            'content': this.getElement(this.selectors.INPUT_TEXTAREA).value,\n            'agentMode': false\n        };\n\n        if (element.loadingState) {\n            await this._addMessageToChatArea({element: temporaryPromptMessage});\n            await this._addMessageToChatArea({element: loadingSpinnerMessage});\n            const inputTextarea = this.getElement(this.selectors.INPUT_TEXTAREA);\n            inputTextarea.value = '';\n            // Very hacky, but we need to fire this event manually to trigger the auto-resize.\n            inputTextarea.dispatchEvent(new Event('input'));\n        }\n    }\n\n    _handleKeyDownOnInputTextarea(event) {\n        if (event.key === 'Enter' && !event.shiftKey) {\n            event.preventDefault();\n            this._submitAiRequestListener();\n        }\n    }\n\n    _removeCurrentPersona() {\n        this.reactive.dispatch('selectCurrentPersona', 0);\n    }\n\n    async _renderContent() {\n        const {html, js} = await Templates.renderForPromise(\n            'block_ai_chat/chat_content',\n            {conversationContextLimit: this.reactive.state.config.conversationContextLimit}\n        );\n        Templates.replaceNodeContents(this.getElement(), html, js);\n        await this._setupAfterContentRendering();\n\n        // Notify that chat content has been rendered.\n        const modal = this.element.closest('.block_ai_chat_reactive_main_component');\n        if (modal) {\n            notifyChatContentRendered(modal);\n        }\n\n        const availabilityErrorMessage = await this.isAiChatAvailable();\n        if (availabilityErrorMessage !== '') {\n            const notice = await getString('notice', 'block_ai_chat');\n            await displayAlert(notice, availabilityErrorMessage);\n            this.setElementLocked(this.getElement(this.selectors.INPUT_TEXTAREA), true);\n            this.setElementLocked(this.getElement(this.selectors.SUBMIT_BUTTON), true);\n            this.getElement(this.selectors.INPUT_TEXTAREA).disabled = true;\n            this.getElement(this.selectors.SUBMIT_BUTTON).disabled = true;\n        }\n    }\n\n    async _setupAfterContentRendering() {\n        this.reactive.dispatch('loadCurrentConversationMessages');\n        const inputTextarea = this.getElement(this.selectors.INPUT_TEXTAREA);\n        const sendRequestButton = this.getElement(this.selectors.SUBMIT_BUTTON);\n        const tinyAiButton = this.getElement(this.selectors.TINY_AI_BUTTON);\n        const uniqid = Math.random().toString(16).slice(2);\n\n        await TinyAiUtils.init(uniqid, this.reactive.state.static.contextid, TinyAiConstants.modalModes.standalone);\n        this.addEventListener(tinyAiButton, 'click', async() => {\n            // We try to find selected text or images and inject it into the AI tools.\n            const selectionObject = window.getSelection();\n            if (selectionObject.rangeCount > 0) {\n                // Safari browser does not really comply with MDN standard and sometimes has\n                // rangeCount === 0. So we have to check for this to avoid running into an error.\n                const range = selectionObject.getRangeAt(0);\n                const container = document.createElement('div');\n                container.appendChild(range.cloneContents());\n                const images = container.querySelectorAll('img');\n                if (images.length > 0 && images[0].src) {\n                    // If there are more than one we just use the first one.\n                    const image = images[0];\n                    // This should work for both external and data urls.\n                    const fetchResult = await fetch(image.src);\n                    const data = await fetchResult.blob();\n                    TinyAiUtils.getDatamanager(uniqid).setSelectionImg(data);\n                }\n\n                // If currently there is text selected we inject it.\n                if (selectionObject.toString() && selectionObject.toString().length > 0) {\n                    TinyAiUtils.getDatamanager(uniqid).setSelection(selectionObject.toString());\n                }\n            }\n\n            const editorUtils = new TinyAiEditorUtils(\n                uniqid,\n                'block_ai_chat',\n                this.reactive.state.static.contextid,\n                this.reactive.state.static.userid,\n                null\n            );\n            TinyAiUtils.setEditorUtils(uniqid, editorUtils);\n            await editorUtils.displayDialogue();\n        });\n\n        this.addEventListener(sendRequestButton, 'click', this._submitAiRequestListener);\n        this.addEventListener(inputTextarea, 'keydown', this._handleKeyDownOnInputTextarea);\n\n        this._scrollToBottom();\n        this._enableTextAreaAutoResize();\n        this._focusInputTextarea();\n    }\n\n    getViewName() {\n        return 'chat';\n    }\n\n    _scrollToBottom() {\n        const chatOutputWrapper = this.getElement(this.selectors.OUTPUT_WRAPPER);\n        chatOutputWrapper.scrollTop = chatOutputWrapper.scrollHeight;\n    }\n\n    _focusInputTextarea() {\n        const inputTextarea = this.getElement(this.selectors.INPUT_TEXTAREA);\n        requestAnimationFrame(() => {\n            inputTextarea.focus();\n        });\n    }\n\n    _enableTextAreaAutoResize() {\n        const inputTextarea = this.getElement(this.selectors.INPUT_TEXTAREA);\n        this.addEventListener(inputTextarea, 'input', () => {\n            // Handle autogrow/-shrink.\n            // Reset the height to auto to get the correct scrollHeight.\n            inputTextarea.style.height = 'auto';\n\n            // Fetch the computed styles.\n            const computedStyles = window.getComputedStyle(inputTextarea);\n            const lineHeight = parseFloat(computedStyles.lineHeight);\n            const paddingTop = parseFloat(computedStyles.paddingTop);\n            const paddingBottom = parseFloat(computedStyles.paddingBottom);\n            const borderTop = parseFloat(computedStyles.borderTopWidth);\n            const borderBottom = parseFloat(computedStyles.borderBottomWidth);\n\n            // Calculate the maximum height for four rows plus padding and borders.\n            const maxHeight = (lineHeight * 4) + paddingTop + paddingBottom + borderTop + borderBottom;\n\n            // Calculate the new height based on the scrollHeight.\n            const newHeight = Math.min(inputTextarea.scrollHeight + borderTop + borderBottom, maxHeight);\n\n            // Set the new height.\n            inputTextarea.style.height = newHeight + 'px';\n        });\n    }\n\n    /**\n     * Is user allowed to use the chatbot.\n     *\n     * @returns {string} Empty string if available, error message if not.\n     */\n    async isAiChatAvailable() {\n        const contextid = this.reactive.state.static.contextid;\n        const aiConfig = await getAiConfig(contextid, null, ['chat']);\n        if (aiConfig.availability.available === 'disabled') {\n            return aiConfig.availability.errormessage;\n        }\n        if (aiConfig.purposes[0].available === 'disabled') {\n            return aiConfig.purposes[0].errormessage;\n        }\n        return '';\n    }\n\n    _getAgentAnswerTemplateContext(content) {\n        const agentAnswer = JSON.parse(content);\n        const chatOutputIntroObject = agentAnswer.chatoutput.filter(object => object.type === 'intro')[0];\n        const chatOutputOutroObject = agentAnswer.chatoutput.filter(object => object.type === 'outro')[0];\n        const suggestionContext = {\n            intro: chatOutputIntroObject.text,\n            suggestions: [],\n            outro: chatOutputOutroObject.text\n        };\n        agentAnswer.formelements.forEach(async(formElement) => {\n                const htmlElement = document.getElementById(formElement.id);\n                let newValue = formElement.newValue.trim();\n                if (newValue.length === 0) {\n                    newValue = 0;\n                }\n                suggestionContext.suggestions.push({\n                    fieldname: formElement.label,\n                    explanation: formElement.explanation,\n                    elementId: formElement.id,\n                    suggestionvalue: newValue,\n                    suggestiondisplayvalue: newValue,\n                    disabledButtons: !htmlElement\n                });\n            }\n        );\n        return suggestionContext;\n    }\n}\n\nexport default Chat;\n"],"names":["Chat","BaseContent","target","this","element","document","querySelector","create","name","selectors","MESSAGES","INPUT_TEXTAREA","SUBMIT_BUTTON","LOADING_SPINNER_MESSAGE","TEMPORARY_PROMPT_MESSAGE","TINY_AI_BUTTON","OUTPUT_WRAPPER","CHAT_OUTPUT","HISTORY_MARKER","reactive","dispatch","getWatchers","super","watch","handler","_addMessageToChatArea","state","config","currentPersona","_removeCurrentPersona","_handleLoadingStateUpdated","placeholder","createElement","setAttribute","id","node","getElement","appendChild","responseIsAgentResponse","messageMode","templateData","agentMode","senderai","sender","loading","hasOwnProperty","agentResponse","_getAgentAnswerTemplateContext","content","newelement","renderComponent","replaceChild","messageId","_scrollToBottom","_focusInputTextarea","prompt","value","trim","errorString","additionalOptions","mode","MODES","AGENT","agentoptions","formelements","DomExtractor","extractDomElements","pageid","body","loadingSpinnerMessage","temporaryPromptMessage","loadingState","inputTextarea","dispatchEvent","Event","_handleKeyDownOnInputTextarea","event","key","shiftKey","preventDefault","_submitAiRequestListener","html","js","Templates","renderForPromise","conversationContextLimit","replaceNodeContents","_setupAfterContentRendering","modal","closest","availabilityErrorMessage","isAiChatAvailable","notice","setElementLocked","disabled","sendRequestButton","tinyAiButton","uniqid","Math","random","toString","slice","TinyAiUtils","init","static","contextid","TinyAiConstants","modalModes","standalone","addEventListener","async","selectionObject","window","getSelection","rangeCount","range","getRangeAt","container","cloneContents","images","querySelectorAll","length","src","image","fetchResult","fetch","data","blob","getDatamanager","setSelectionImg","setSelection","editorUtils","TinyAiEditorUtils","userid","setEditorUtils","displayDialogue","_enableTextAreaAutoResize","getViewName","chatOutputWrapper","scrollTop","scrollHeight","requestAnimationFrame","focus","style","height","computedStyles","getComputedStyle","lineHeight","parseFloat","paddingTop","paddingBottom","borderTop","borderTopWidth","borderBottom","borderBottomWidth","maxHeight","newHeight","min","aiConfig","availability","available","errormessage","purposes","agentAnswer","JSON","parse","chatOutputIntroObject","chatoutput","filter","object","type","chatOutputOutroObject","suggestionContext","intro","text","suggestions","outro","forEach","htmlElement","getElementById","formElement","newValue","push","fieldname","label","explanation","elementId","suggestionvalue","suggestiondisplayvalue","disabledButtons"],"mappings":"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"}