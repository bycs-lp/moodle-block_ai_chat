{"version":3,"file":"chat.min.js","sources":["../../src/components/chat.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport BaseContent from 'block_ai_chat/components/base_content';\nimport * as TinyAiUtils from 'tiny_ai/utils';\nimport TinyAiEditorUtils from 'tiny_ai/editor_utils';\nimport {constants as TinyAiConstants} from 'tiny_ai/constants';\nimport Templates from 'core/templates';\nimport {getAiConfig} from 'local_ai_manager/config';\nimport {getString} from 'core/str';\nimport {alert as displayAlert} from 'core/notification';\nimport {showErrorToast} from 'block_ai_chat/utils';\nimport Popover from 'theme_boost/bootstrap/popover';\n\n\nclass Chat extends BaseContent {\n    /**\n     * Function to initialize component, called by mustache template.\n     *\n     * @param {*} target The id of the HTMLElement to attach to\n     * @returns {BaseComponent} New component attached to the HTMLElement represented by target\n     */\n    static init(target) {\n        let element = document.querySelector(target);\n        return new this({\n            element: element,\n        });\n    }\n\n    /**\n     * It is important to follow some conventions while you write components. This way all components\n     * will be implemented in a similar way and anybody will be able to understand how it works.\n     *\n     * All the component definition should be initialized on the \"create\" method.\n     */\n    create() {\n        this.name = 'ChatComponent';\n        this.selectors = {\n            MESSAGES: `[data-block_ai_chat-element='messages']`,\n            INPUT_TEXTAREA: `[data-block_ai_chat-element='inputtextarea']`,\n            SUBMIT_BUTTON: `[data-block_ai_chat-element='submitbutton']`,\n            LOADING_SPINNER_MESSAGE: `[data-block_ai_chat-element='loadingspinner']`,\n            TEMPORARY_PROMPT_MESSAGE: `[data-block_ai_chat-element='temporaryprompt']`,\n            TINY_AI_BUTTON: `[data-block_ai_chat-element='tinyaibutton']`,\n            OUTPUT_WRAPPER: `[data-block_ai_chat-element='outputwrapper']`,\n            CHAT_OUTPUT: `[data-block_ai_chat-element='chatoutput']`,\n            HISTORY_MARKER: `[data-block_ai_chat-element='historymarker']`,\n        };\n    }\n\n    /**\n     * Initial state ready method.\n     *\n     * Initially calls the setView action to set the view to 'chat' once ready to trigger the first\n     * rendering of itself.\n     */\n    async stateReady() {\n        this.reactive.dispatch('setView', 'chat');\n    }\n\n    getWatchers() {\n        return [\n            ...super.getWatchers(),\n            {watch: `messages:created`, handler: this._addMessageToChatArea},\n            {watch: `messages:created`, handler: this._updateHistoryMarker},\n            {watch: `messages:deleted`, handler: this._updateHistoryMarker},\n            {watch: `config.conversationContextLimit:updated`, handler: this._updateHistoryMarker},\n            {watch: `personas${this.reactive.state.config.currentPersona}:deleted`, handler: this._removeCurrentPersona},\n            {watch: `config.loadingState:updated`, handler: this._handleLoadingStateUpdated},\n        ];\n    }\n\n    async _addMessageToChatArea({element}) {\n        let placeholder = document.createElement('div');\n        placeholder.setAttribute('data-id', element.id);\n        let node = this.getElement(this.selectors.CHAT_OUTPUT);\n        node.appendChild(placeholder);\n        const templateData = {\n            id: element.id,\n            senderai: element.sender === 'ai',\n            content: element.content,\n            loading: element.hasOwnProperty('loading') ? element.loading : false,\n        };\n        const newcomponent = await this.renderComponent(placeholder, 'block_ai_chat/components/message', templateData);\n        const newelement = newcomponent.getElement();\n        node.replaceChild(newelement, placeholder);\n        this._scrollToBottom();\n        this._focusInputTextarea();\n    }\n\n\n    async _submitAiRequestListener() {\n        const textarea = this.getElement(this.selectors.INPUT_TEXTAREA);\n        const prompt = textarea.value;\n        if (prompt.trim() === '') {\n            const errorString = getString('erroremptyprompt', 'block_ai_chat');\n            await showErrorToast(errorString);\n            return;\n        }\n        this.reactive.dispatch('submitAiRequest', prompt);\n    }\n\n    async _handleLoadingStateUpdated({element}) {\n        const loadingSpinnerMessage = {\n            'id': 'loadingspinner',\n            'sender': 'ai',\n            'loading': true\n        };\n\n        const temporaryPromptMessage = {\n            'id': 'temporaryprompt',\n            'sender': 'user',\n            'content': this.getElement(this.selectors.INPUT_TEXTAREA).value,\n        };\n\n        if (element.loadingState) {\n            await this._addMessageToChatArea({element: temporaryPromptMessage});\n            await this._addMessageToChatArea({element: loadingSpinnerMessage});\n            this.getElement(this.selectors.INPUT_TEXTAREA).value = '';\n        }\n    }\n\n    _handleKeyDownOnInputTextarea(event) {\n        if (event.key === 'Enter' && !event.shiftKey) {\n            event.preventDefault();\n            this._submitAiRequestListener();\n        }\n    }\n\n    _removeCurrentPersona() {\n        this.reactive.dispatch('selectCurrentPersona', 0);\n    }\n\n    async _updateHistoryMarker() {\n        setTimeout(async() => {\n            // Remove existing marker\n            const existingMarker = this.getElement().querySelector(this.selectors.HISTORY_MARKER);\n            if (existingMarker) {\n                existingMarker.remove();\n            }\n\n            const chatOutput = this.getElement(this.selectors.CHAT_OUTPUT);\n            if (!chatOutput) {\n                return;\n            }\n\n            const messages = Array.from(chatOutput.querySelectorAll('[data-block_ai_chat-component=\"message\"]'));\n            const contextLimit = this.reactive.state.config.conversationContextLimit;\n\n            if (messages.length <= contextLimit) {\n                return;\n            }\n\n            // Marker position: after message at index (length - 2 * contextLimit - 1).\n            // History length of 4 messages actually means 4 user messages and 4 AI messages = 8 messages total.\n            const markerPosition = messages.length - 2 * contextLimit - 1;\n            const messageBeforeContext = messages[markerPosition];\n\n            if (messageBeforeContext) {\n                const marker = document.createElement('div');\n                marker.setAttribute('data-block_ai_chat-element', 'historymarker');\n                marker.className = 'block_ai_chat-history-marker';\n\n                // Fetch the string for the popover content\n                const historyLengthInfo = await getString('historylengthinfo', 'block_ai_chat');\n                // TODO Refactor to template.\n                marker.innerHTML = `\n                    <hr class=\"block_ai_chat-history-line\">\n                    <span class=\"badge rounded-pill text-primary bg-secondary cursor-pointer\" role=\"button\" tabindex=\"0\"\n                        data-bs-container=\"body\" data-bs-toggle=\"popover\" data-bs-placement=\"top\"\n                        data-bs-content=\"${historyLengthInfo}\" data-bs-trigger=\"focus\"\n                        aria-label=\"${historyLengthInfo}\">${contextLimit}</span>\n                `;\n\n                messageBeforeContext.after(marker);\n\n                // Initialize the popover\n                const badgeElement = marker.querySelector('.badge');\n                if (badgeElement) {\n                    new Popover(badgeElement);\n                }\n            }\n        }, 100);\n    }\n\n    async _renderContent() {\n        const {html, js} = await Templates.renderForPromise('block_ai_chat/chat_content', {});\n        Templates.replaceNodeContents(this.getElement(), html, js);\n        await this._setupAfterContentRendering();\n        const availabilityErrorMessage = await this.isAiChatAvailable();\n        if (availabilityErrorMessage !== '') {\n            const notice = await getString('notice', 'block_ai_chat');\n            await displayAlert(notice, availabilityErrorMessage);\n            this.setElementLocked(this.getElement(this.selectors.INPUT_TEXTAREA), true);\n            this.setElementLocked(this.getElement(this.selectors.SUBMIT_BUTTON), true);\n            this.getElement(this.selectors.INPUT_TEXTAREA).disabled = true;\n            this.getElement(this.selectors.SUBMIT_BUTTON).disabled = true;\n        }\n    }\n\n    async _setupAfterContentRendering() {\n        this.reactive.dispatch('loadCurrentConversationMessages');\n        const inputTextarea = this.getElement(this.selectors.INPUT_TEXTAREA);\n        const sendRequestButton = this.getElement(this.selectors.SUBMIT_BUTTON);\n        const tinyAiButton = this.getElement(this.selectors.TINY_AI_BUTTON);\n        const uniqid = Math.random().toString(16).slice(2);\n\n        await TinyAiUtils.init(uniqid, this.reactive.state.static.contextid, TinyAiConstants.modalModes.standalone);\n        this.addEventListener(tinyAiButton, 'click', async() => {\n            // We try to find selected text or images and inject it into the AI tools.\n            const selectionObject = window.getSelection();\n            if (selectionObject.rangeCount > 0) {\n                // Safari browser does not really comply with MDN standard and sometimes has\n                // rangeCount === 0. So we have to check for this to avoid running into an error.\n                const range = selectionObject.getRangeAt(0);\n                const container = document.createElement('div');\n                container.appendChild(range.cloneContents());\n                const images = container.querySelectorAll('img');\n                if (images.length > 0 && images[0].src) {\n                    // If there are more than one we just use the first one.\n                    const image = images[0];\n                    // This should work for both external and data urls.\n                    const fetchResult = await fetch(image.src);\n                    const data = await fetchResult.blob();\n                    TinyAiUtils.getDatamanager(uniqid).setSelectionImg(data);\n                }\n\n                // If currently there is text selected we inject it.\n                if (selectionObject.toString() && selectionObject.toString().length > 0) {\n                    TinyAiUtils.getDatamanager(uniqid).setSelection(selectionObject.toString());\n                }\n            }\n\n            const editorUtils = new TinyAiEditorUtils(\n                uniqid,\n                'block_ai_chat',\n                this.reactive.state.static.contextid,\n                this.reactive.state.static.userid,\n                null\n            );\n            TinyAiUtils.setEditorUtils(uniqid, editorUtils);\n            await editorUtils.displayDialogue();\n        });\n\n        this.addEventListener(sendRequestButton, 'click', this._submitAiRequestListener);\n        this.addEventListener(inputTextarea, 'keydown', this._handleKeyDownOnInputTextarea);\n\n        this._scrollToBottom();\n        this._updateHistoryMarker();\n        this._enableTextAreaAutoResize();\n        this._focusInputTextarea();\n    }\n\n    getViewName() {\n        return 'chat';\n    }\n\n    _scrollToBottom() {\n        const chatOutputWrapper = this.getElement(this.selectors.OUTPUT_WRAPPER);\n        chatOutputWrapper.scrollTop = chatOutputWrapper.scrollHeight;\n    }\n\n    _focusInputTextarea() {\n        const inputTextarea = this.getElement(this.selectors.INPUT_TEXTAREA);\n        requestAnimationFrame(() => {\n            inputTextarea.focus();\n        });\n    }\n\n    _enableTextAreaAutoResize() {\n        const inputTextarea = this.getElement(this.selectors.INPUT_TEXTAREA);\n        this.addEventListener(inputTextarea, 'keydown', () => {\n            // Handle autogrow/-shrink.\n            // Reset the height to auto to get the correct scrollHeight.\n            inputTextarea.style.height = 'auto';\n\n            // Fetch the computed styles.\n            const computedStyles = window.getComputedStyle(inputTextarea);\n            const lineHeight = parseFloat(computedStyles.lineHeight);\n            const paddingTop = parseFloat(computedStyles.paddingTop);\n            const paddingBottom = parseFloat(computedStyles.paddingBottom);\n            const borderTop = parseFloat(computedStyles.borderTopWidth);\n            const borderBottom = parseFloat(computedStyles.borderBottomWidth);\n\n            // Calculate the maximum height for four rows plus padding and borders.\n            const maxHeight = (lineHeight * 4) + paddingTop + paddingBottom + borderTop + borderBottom;\n\n            // Calculate the new height based on the scrollHeight.\n            const newHeight = Math.min(inputTextarea.scrollHeight + borderTop + borderBottom, maxHeight);\n\n            // Set the new height.\n            inputTextarea.style.height = newHeight + 'px';\n        });\n    }\n\n    /**\n     * Is user allowed to use the chatbot.\n     *\n     * @returns {string} Empty string if available, error message if not.\n     */\n    async isAiChatAvailable() {\n        const contextid = this.reactive.state.static.contextid;\n        const aiConfig = await getAiConfig(contextid, null, ['chat']);\n        if (aiConfig.availability.available === 'disabled') {\n            return aiConfig.availability.errormessage;\n        }\n        if (aiConfig.purposes[0].available === 'disabled') {\n            return aiConfig.purposes[0].errormessage;\n        }\n        return '';\n    }\n\n}\n\nexport default Chat;\n"],"names":["Chat","BaseContent","target","this","element","document","querySelector","create","name","selectors","MESSAGES","INPUT_TEXTAREA","SUBMIT_BUTTON","LOADING_SPINNER_MESSAGE","TEMPORARY_PROMPT_MESSAGE","TINY_AI_BUTTON","OUTPUT_WRAPPER","CHAT_OUTPUT","HISTORY_MARKER","reactive","dispatch","getWatchers","super","watch","handler","_addMessageToChatArea","_updateHistoryMarker","state","config","currentPersona","_removeCurrentPersona","_handleLoadingStateUpdated","placeholder","createElement","setAttribute","id","node","getElement","appendChild","templateData","senderai","sender","content","loading","hasOwnProperty","newelement","renderComponent","replaceChild","_scrollToBottom","_focusInputTextarea","prompt","value","trim","errorString","loadingSpinnerMessage","temporaryPromptMessage","loadingState","_handleKeyDownOnInputTextarea","event","key","shiftKey","preventDefault","_submitAiRequestListener","setTimeout","async","existingMarker","remove","chatOutput","messages","Array","from","querySelectorAll","contextLimit","conversationContextLimit","length","messageBeforeContext","marker","className","historyLengthInfo","innerHTML","after","badgeElement","Popover","html","js","Templates","renderForPromise","replaceNodeContents","_setupAfterContentRendering","availabilityErrorMessage","isAiChatAvailable","notice","setElementLocked","disabled","inputTextarea","sendRequestButton","tinyAiButton","uniqid","Math","random","toString","slice","TinyAiUtils","init","static","contextid","TinyAiConstants","modalModes","standalone","addEventListener","selectionObject","window","getSelection","rangeCount","range","getRangeAt","container","cloneContents","images","src","image","fetchResult","fetch","data","blob","getDatamanager","setSelectionImg","setSelection","editorUtils","TinyAiEditorUtils","userid","setEditorUtils","displayDialogue","_enableTextAreaAutoResize","getViewName","chatOutputWrapper","scrollTop","scrollHeight","requestAnimationFrame","focus","style","height","computedStyles","getComputedStyle","lineHeight","parseFloat","paddingTop","paddingBottom","borderTop","borderTopWidth","borderBottom","borderBottomWidth","maxHeight","newHeight","min","aiConfig","availability","available","errormessage","purposes"],"mappings":"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"}