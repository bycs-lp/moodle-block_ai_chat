{"version":3,"file":"chat.min.js","sources":["../../src/components/chat.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport BaseContent from 'block_ai_chat/components/base_content';\nimport * as TinyAiUtils from 'tiny_ai/utils';\nimport TinyAiEditorUtils from 'tiny_ai/editor_utils';\nimport {constants as TinyAiConstants} from 'tiny_ai/constants';\nimport Templates from 'core/templates';\nimport {getAiConfig} from 'local_ai_manager/config';\nimport {getString} from 'core/str';\nimport {alert as displayAlert} from 'core/notification';\nimport {showErrorToast} from 'block_ai_chat/utils';\nimport Popover from 'theme_boost/bootstrap/popover';\nimport {MODES} from 'block_ai_chat/constants';\nimport * as DomExtractor from 'block_ai_chat/dom_extractor';\n\n\nclass Chat extends BaseContent {\n    /**\n     * Function to initialize component, called by mustache template.\n     *\n     * @param {*} target The id of the HTMLElement to attach to\n     * @returns {BaseComponent} New component attached to the HTMLElement represented by target\n     */\n    static init(target) {\n        let element = document.querySelector(target);\n        return new this({\n            element: element,\n        });\n    }\n\n    /**\n     * It is important to follow some conventions while you write components. This way all components\n     * will be implemented in a similar way and anybody will be able to understand how it works.\n     *\n     * All the component definition should be initialized on the \"create\" method.\n     */\n    create() {\n        this.name = 'ChatComponent';\n        this.selectors = {\n            MESSAGES: `[data-block_ai_chat-element='messages']`,\n            INPUT_TEXTAREA: `[data-block_ai_chat-element='inputtextarea']`,\n            SUBMIT_BUTTON: `[data-block_ai_chat-element='submitbutton']`,\n            LOADING_SPINNER_MESSAGE: `[data-block_ai_chat-element='loadingspinner']`,\n            TEMPORARY_PROMPT_MESSAGE: `[data-block_ai_chat-element='temporaryprompt']`,\n            TINY_AI_BUTTON: `[data-block_ai_chat-element='tinyaibutton']`,\n            OUTPUT_WRAPPER: `[data-block_ai_chat-element='outputwrapper']`,\n            CHAT_OUTPUT: `[data-block_ai_chat-element='chatoutput']`,\n            HISTORY_MARKER: `[data-block_ai_chat-element='historymarker']`,\n        };\n    }\n\n    /**\n     * Initial state ready method.\n     *\n     * Initially calls the setView action to set the view to 'chat' once ready to trigger the first\n     * rendering of itself.\n     */\n    async stateReady() {\n        this.reactive.dispatch('setView', 'chat');\n    }\n\n    getWatchers() {\n        return [\n            ...super.getWatchers(),\n            {watch: `messages:created`, handler: this._addMessageToChatArea},\n            {watch: `messages:created`, handler: this._updateHistoryMarker},\n            {watch: `messages:deleted`, handler: this._updateHistoryMarker},\n            {watch: `config.conversationContextLimit:updated`, handler: this._updateHistoryMarker},\n            {watch: `personas${this.reactive.state.config.currentPersona}:deleted`, handler: this._removeCurrentPersona},\n            {watch: `config.loadingState:updated`, handler: this._handleLoadingStateUpdated},\n        ];\n    }\n\n    async _addMessageToChatArea({element}) {\n        let placeholder = document.createElement('div');\n        placeholder.setAttribute('data-id', element.id);\n        let node = this.getElement(this.selectors.CHAT_OUTPUT);\n        node.appendChild(placeholder);\n\n        const responseIsAgentResponse = element.messageMode === 'agent';\n\n        let templateData = {\n            id: element.id,\n            agentMode: responseIsAgentResponse,\n            senderai: element.sender === 'ai',\n            loading: element.hasOwnProperty('loading') ? element.loading : false,\n        };\n        if (responseIsAgentResponse) {\n            const agentResponse = responseIsAgentResponse ? this._getAgentAnswerTemplateContext(element.content) : {};\n            templateData = {...templateData, ...agentResponse};\n        } else {\n            templateData.content = element.content;\n        }\n        const newcomponent = await this.renderComponent(placeholder, 'block_ai_chat/components/message', templateData);\n        const newelement = newcomponent.getElement();\n        node.replaceChild(newelement, placeholder);\n        this._scrollToBottom();\n        this._focusInputTextarea();\n    }\n\n\n    async _submitAiRequestListener() {\n        const textarea = this.getElement(this.selectors.INPUT_TEXTAREA);\n        const prompt = textarea.value;\n        if (prompt.trim() === '') {\n            const errorString = getString('erroremptyprompt', 'block_ai_chat');\n            await showErrorToast(errorString);\n            return;\n        }\n        const additionalOptions = {};\n        if (this.reactive.state.config.mode === MODES.AGENT) {\n            additionalOptions.agentoptions = {\n                formelements: DomExtractor.extractDomElements(),\n                pageid: document.body.id\n            };\n        }\n        this.reactive.dispatch('submitAiRequest', prompt, additionalOptions);\n    }\n\n    async _handleLoadingStateUpdated({element}) {\n        const loadingSpinnerMessage = {\n            'id': 'loadingspinner',\n            'sender': 'ai',\n            'loading': true,\n            'agentMode': false\n        };\n\n        const temporaryPromptMessage = {\n            'id': 'temporaryprompt',\n            'sender': 'user',\n            'content': this.getElement(this.selectors.INPUT_TEXTAREA).value,\n            'agentMode': false\n        };\n\n        if (element.loadingState) {\n            await this._addMessageToChatArea({element: temporaryPromptMessage});\n            await this._addMessageToChatArea({element: loadingSpinnerMessage});\n            this.getElement(this.selectors.INPUT_TEXTAREA).value = '';\n        }\n    }\n\n    _handleKeyDownOnInputTextarea(event) {\n        if (event.key === 'Enter' && !event.shiftKey) {\n            event.preventDefault();\n            this._submitAiRequestListener();\n        }\n    }\n\n    _removeCurrentPersona() {\n        this.reactive.dispatch('selectCurrentPersona', 0);\n    }\n\n    async _updateHistoryMarker() {\n        setTimeout(async() => {\n            // Remove existing marker\n            const existingMarker = this.getElement().querySelector(this.selectors.HISTORY_MARKER);\n            if (existingMarker) {\n                existingMarker.remove();\n            }\n\n            const chatOutput = this.getElement(this.selectors.CHAT_OUTPUT);\n            if (!chatOutput) {\n                return;\n            }\n\n            const messages = Array.from(chatOutput.querySelectorAll('[data-block_ai_chat-component=\"message\"]'));\n            const contextLimit = this.reactive.state.config.conversationContextLimit;\n\n            if (messages.length <= contextLimit) {\n                return;\n            }\n\n            // Marker position: after message at index (length - 2 * contextLimit - 1).\n            // History length of 4 messages actually means 4 user messages and 4 AI messages = 8 messages total.\n            const markerPosition = messages.length - 2 * contextLimit - 1;\n            const messageBeforeContext = messages[markerPosition];\n\n            if (messageBeforeContext) {\n                const marker = document.createElement('div');\n                marker.setAttribute('data-block_ai_chat-element', 'historymarker');\n                marker.className = 'block_ai_chat-history-marker';\n\n                // Fetch the string for the popover content\n                const historyLengthInfo = await getString('historylengthinfo', 'block_ai_chat');\n                // TODO Refactor to template.\n                marker.innerHTML = `\n                    <hr class=\"block_ai_chat-history-line\">\n                    <span class=\"badge rounded-pill text-primary bg-secondary cursor-pointer\" role=\"button\" tabindex=\"0\"\n                        data-bs-container=\"body\" data-bs-toggle=\"popover\" data-bs-placement=\"top\"\n                        data-bs-content=\"${historyLengthInfo}\" data-bs-trigger=\"focus\"\n                        aria-label=\"${historyLengthInfo}\">${contextLimit}</span>\n                `;\n\n                messageBeforeContext.after(marker);\n\n                // Initialize the popover\n                const badgeElement = marker.querySelector('.badge');\n                if (badgeElement) {\n                    new Popover(badgeElement);\n                }\n            }\n        }, 100);\n    }\n\n    async _renderContent() {\n        const {html, js} = await Templates.renderForPromise('block_ai_chat/chat_content', {});\n        Templates.replaceNodeContents(this.getElement(), html, js);\n        await this._setupAfterContentRendering();\n        const availabilityErrorMessage = await this.isAiChatAvailable();\n        if (availabilityErrorMessage !== '') {\n            const notice = await getString('notice', 'block_ai_chat');\n            await displayAlert(notice, availabilityErrorMessage);\n            this.setElementLocked(this.getElement(this.selectors.INPUT_TEXTAREA), true);\n            this.setElementLocked(this.getElement(this.selectors.SUBMIT_BUTTON), true);\n            this.getElement(this.selectors.INPUT_TEXTAREA).disabled = true;\n            this.getElement(this.selectors.SUBMIT_BUTTON).disabled = true;\n        }\n    }\n\n    async _setupAfterContentRendering() {\n        this.reactive.dispatch('loadCurrentConversationMessages');\n        const inputTextarea = this.getElement(this.selectors.INPUT_TEXTAREA);\n        const sendRequestButton = this.getElement(this.selectors.SUBMIT_BUTTON);\n        const tinyAiButton = this.getElement(this.selectors.TINY_AI_BUTTON);\n        const uniqid = Math.random().toString(16).slice(2);\n\n        await TinyAiUtils.init(uniqid, this.reactive.state.static.contextid, TinyAiConstants.modalModes.standalone);\n        this.addEventListener(tinyAiButton, 'click', async() => {\n            // We try to find selected text or images and inject it into the AI tools.\n            const selectionObject = window.getSelection();\n            if (selectionObject.rangeCount > 0) {\n                // Safari browser does not really comply with MDN standard and sometimes has\n                // rangeCount === 0. So we have to check for this to avoid running into an error.\n                const range = selectionObject.getRangeAt(0);\n                const container = document.createElement('div');\n                container.appendChild(range.cloneContents());\n                const images = container.querySelectorAll('img');\n                if (images.length > 0 && images[0].src) {\n                    // If there are more than one we just use the first one.\n                    const image = images[0];\n                    // This should work for both external and data urls.\n                    const fetchResult = await fetch(image.src);\n                    const data = await fetchResult.blob();\n                    TinyAiUtils.getDatamanager(uniqid).setSelectionImg(data);\n                }\n\n                // If currently there is text selected we inject it.\n                if (selectionObject.toString() && selectionObject.toString().length > 0) {\n                    TinyAiUtils.getDatamanager(uniqid).setSelection(selectionObject.toString());\n                }\n            }\n\n            const editorUtils = new TinyAiEditorUtils(\n                uniqid,\n                'block_ai_chat',\n                this.reactive.state.static.contextid,\n                this.reactive.state.static.userid,\n                null\n            );\n            TinyAiUtils.setEditorUtils(uniqid, editorUtils);\n            await editorUtils.displayDialogue();\n        });\n\n        this.addEventListener(sendRequestButton, 'click', this._submitAiRequestListener);\n        this.addEventListener(inputTextarea, 'keydown', this._handleKeyDownOnInputTextarea);\n\n        this._scrollToBottom();\n        await this._updateHistoryMarker();\n        this._enableTextAreaAutoResize();\n        this._focusInputTextarea();\n    }\n\n    getViewName() {\n        return 'chat';\n    }\n\n    _scrollToBottom() {\n        const chatOutputWrapper = this.getElement(this.selectors.OUTPUT_WRAPPER);\n        chatOutputWrapper.scrollTop = chatOutputWrapper.scrollHeight;\n    }\n\n    _focusInputTextarea() {\n        const inputTextarea = this.getElement(this.selectors.INPUT_TEXTAREA);\n        requestAnimationFrame(() => {\n            inputTextarea.focus();\n        });\n    }\n\n    _enableTextAreaAutoResize() {\n        const inputTextarea = this.getElement(this.selectors.INPUT_TEXTAREA);\n        this.addEventListener(inputTextarea, 'keydown', () => {\n            // Handle autogrow/-shrink.\n            // Reset the height to auto to get the correct scrollHeight.\n            inputTextarea.style.height = 'auto';\n\n            // Fetch the computed styles.\n            const computedStyles = window.getComputedStyle(inputTextarea);\n            const lineHeight = parseFloat(computedStyles.lineHeight);\n            const paddingTop = parseFloat(computedStyles.paddingTop);\n            const paddingBottom = parseFloat(computedStyles.paddingBottom);\n            const borderTop = parseFloat(computedStyles.borderTopWidth);\n            const borderBottom = parseFloat(computedStyles.borderBottomWidth);\n\n            // Calculate the maximum height for four rows plus padding and borders.\n            const maxHeight = (lineHeight * 4) + paddingTop + paddingBottom + borderTop + borderBottom;\n\n            // Calculate the new height based on the scrollHeight.\n            const newHeight = Math.min(inputTextarea.scrollHeight + borderTop + borderBottom, maxHeight);\n\n            // Set the new height.\n            inputTextarea.style.height = newHeight + 'px';\n        });\n    }\n\n    /**\n     * Is user allowed to use the chatbot.\n     *\n     * @returns {string} Empty string if available, error message if not.\n     */\n    async isAiChatAvailable() {\n        const contextid = this.reactive.state.static.contextid;\n        const aiConfig = await getAiConfig(contextid, null, ['chat']);\n        if (aiConfig.availability.available === 'disabled') {\n            return aiConfig.availability.errormessage;\n        }\n        if (aiConfig.purposes[0].available === 'disabled') {\n            return aiConfig.purposes[0].errormessage;\n        }\n        return '';\n    }\n\n    _getAgentAnswerTemplateContext(content) {\n        const agentAnswer = JSON.parse(content);\n        const chatOutputIntroObject = agentAnswer.chatoutput.filter(object => object.type === 'intro')[0];\n        const chatOutputOutroObject = agentAnswer.chatoutput.filter(object => object.type === 'outro')[0];\n        const suggestionContext = {\n            intro: chatOutputIntroObject.text,\n            suggestions: [],\n            outro: chatOutputOutroObject.text\n        };\n        agentAnswer.formelements.forEach(async(formElement) => {\n                const htmlElement = document.getElementById(formElement.id);\n                let newValue = formElement.newValue.trim();\n                if (newValue.length === 0) {\n                    newValue = 0;\n                }\n                suggestionContext.suggestions.push({\n                    fieldname: formElement.label,\n                    explanation: formElement.explanation,\n                    elementId: formElement.id,\n                    suggestionvalue: newValue,\n                    suggestiondisplayvalue: newValue,\n                    disabledButtons: !htmlElement\n                });\n            }\n        );\n        return suggestionContext;\n    }\n}\n\nexport default Chat;\n"],"names":["Chat","BaseContent","target","this","element","document","querySelector","create","name","selectors","MESSAGES","INPUT_TEXTAREA","SUBMIT_BUTTON","LOADING_SPINNER_MESSAGE","TEMPORARY_PROMPT_MESSAGE","TINY_AI_BUTTON","OUTPUT_WRAPPER","CHAT_OUTPUT","HISTORY_MARKER","reactive","dispatch","getWatchers","super","watch","handler","_addMessageToChatArea","_updateHistoryMarker","state","config","currentPersona","_removeCurrentPersona","_handleLoadingStateUpdated","placeholder","createElement","setAttribute","id","node","getElement","appendChild","responseIsAgentResponse","messageMode","templateData","agentMode","senderai","sender","loading","hasOwnProperty","agentResponse","_getAgentAnswerTemplateContext","content","newelement","renderComponent","replaceChild","_scrollToBottom","_focusInputTextarea","prompt","value","trim","errorString","additionalOptions","mode","MODES","AGENT","agentoptions","formelements","DomExtractor","extractDomElements","pageid","body","loadingSpinnerMessage","temporaryPromptMessage","loadingState","_handleKeyDownOnInputTextarea","event","key","shiftKey","preventDefault","_submitAiRequestListener","setTimeout","async","existingMarker","remove","chatOutput","messages","Array","from","querySelectorAll","contextLimit","conversationContextLimit","length","messageBeforeContext","marker","className","historyLengthInfo","innerHTML","after","badgeElement","Popover","html","js","Templates","renderForPromise","replaceNodeContents","_setupAfterContentRendering","availabilityErrorMessage","isAiChatAvailable","notice","setElementLocked","disabled","inputTextarea","sendRequestButton","tinyAiButton","uniqid","Math","random","toString","slice","TinyAiUtils","init","static","contextid","TinyAiConstants","modalModes","standalone","addEventListener","selectionObject","window","getSelection","rangeCount","range","getRangeAt","container","cloneContents","images","src","image","fetchResult","fetch","data","blob","getDatamanager","setSelectionImg","setSelection","editorUtils","TinyAiEditorUtils","userid","setEditorUtils","displayDialogue","_enableTextAreaAutoResize","getViewName","chatOutputWrapper","scrollTop","scrollHeight","requestAnimationFrame","focus","style","height","computedStyles","getComputedStyle","lineHeight","parseFloat","paddingTop","paddingBottom","borderTop","borderTopWidth","borderBottom","borderBottomWidth","maxHeight","newHeight","min","aiConfig","availability","available","errormessage","purposes","agentAnswer","JSON","parse","chatOutputIntroObject","chatoutput","filter","object","type","chatOutputOutroObject","suggestionContext","intro","text","suggestions","outro","forEach","htmlElement","getElementById","formElement","newValue","push","fieldname","label","explanation","elementId","suggestionvalue","suggestiondisplayvalue","disabledButtons"],"mappings":"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"}