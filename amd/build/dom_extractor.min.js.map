{"version":3,"file":"dom_extractor.min.js","sources":["../src/dom_extractor.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Extract DOM elements and export them as JSON.\n *\n * @module     block_ai_chat/dom_extractor\n * @copyright  2025 ISB Bayern\n * @author     Dr. Peter Mayer\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/**\n * Get DOM elements inside #page-content and return as JSON.\n *\n * This function scans the page content for form elements and extracts their properties,\n * including values, labels, help text, error messages, and complex dependencies between elements.\n * It supports all major form input types and analyzes their relationships.\n * Additionally, it extracts page context information from h2 headings with help content as additional elements.\n *\n * @returns {Array} Array containing structured form element data with dependencies and page context elements\n */\nexport const extractDomElements = () => {\n    const elements = [];\n\n    // Find the main content container - all Moodle forms are within #page-content.\n    const contentDiv = document.getElementById('page-content');\n    if (!contentDiv) {\n        // Return empty structure if no content area is found.\n        return [];\n    }\n\n    // Comprehensive selector for all form input types including hidden fields and buttons.\n    // This covers standard inputs, textareas, selects, and special Moodle form elements.\n    const selector =\n        'input[type=\"text\"], input[type=\"password\"], input[type=\"email\"], input[type=\"number\"], ' +\n        'input[type=\"search\"], input[type=\"tel\"], input[type=\"url\"], input[type=\"date\"], ' +\n        'input[type=\"datetime-local\"], input[type=\"checkbox\"], input[type=\"radio\"], input[type=\"file\"], ' +\n        'input[type=\"hidden\"], input[type=\"submit\"], input[type=\"button\"], textarea, select';\n\n    const domNodes = contentDiv.querySelectorAll(selector);\n\n    // Process each form element found in the DOM.\n    domNodes.forEach((node) => {\n        let type = node.tagName.toLowerCase();\n        let currentValue = '';\n        const options = [];\n\n        // Extract current value based on element type and special handling for different inputs.\n        if (type === 'input') {\n            type = node.type;\n            if (type === 'checkbox' || type === 'radio') {\n                // For checkboxes and radios, return the value only if checked, otherwise empty.\n                currentValue = node.checked ? node.value || 'on' : '';\n            } else {\n                // For all other input types, get the current value.\n                currentValue = node.value || '';\n            }\n        } else if (type === 'textarea') {\n            type = 'textarea';\n\n            // Special handling for TinyMCE editors which are hidden textareas with iframe content.\n            if (node.style.display === 'none' && node.id) {\n                const tinyFrame = document.querySelector(`#${node.id}_ifr`);\n                if (tinyFrame?.contentDocument) {\n                    try {\n                        // Extract content from TinyMCE iframe body.\n                        const tinyBody = tinyFrame.contentDocument.body;\n                        currentValue = tinyBody ? (tinyBody.textContent || tinyBody.innerText || '') : node.value || '';\n                    } catch (e) {\n                        // Fallback to textarea value if iframe access fails (cross-origin issues).\n                        currentValue = node.value || '';\n                    }\n                } else {\n                    currentValue = node.value || '';\n                }\n            } else {\n                // Standard textarea handling.\n                currentValue = node.value || '';\n            }\n        } else if (type === 'select') {\n            type = 'select';\n\n            // Get selected value from select element.\n            currentValue = node.selectedOptions?.length > 0 ? node.selectedOptions[0].value : (node.value || '');\n\n            // Check if this select is within a date_time container to avoid verbose output.\n            if (!isWithinDateTimeContainer(node)) {\n                const optionElements = node.querySelectorAll('option');\n                optionElements.forEach((option) => {\n                    options.push({\n                        value: option.value,\n                        text: option.textContent || option.innerText || '',\n                        selected: option.selected\n                    });\n                });\n            }\n        }\n\n        // Find the associated label text using multiple strategies for Moodle form conventions.\n        const label = findLabelForElement(node);\n\n        // Extract help text/description that provides additional context for the field.\n        const helptext = findHelptextForElement(node);\n\n        // Extract error text/validation messages for the field.\n        const errorText = findErrorForElement(node);\n\n        // Determine if the element is currently active/enabled (1) or disabled (0).\n        let active = 1;\n        let isDisabled = false;\n        let dependsOnEnabled = null;\n\n        // Check element disabled state using multiple methods to ensure compatibility.\n        // Method 1: Check the disabled property directly.\n        if (node.disabled === true) {\n            isDisabled = true;\n        }\n\n        // Method 2: Check for disabled attribute (covers cases like <select disabled> and <select disabled=\"disabled\">).\n        const attrNode = node.getAttributeNode?.('disabled');\n        if (attrNode?.specified) {\n            isDisabled = true;\n        }\n\n        // Check if element is hidden via CSS styles (but not for hidden input types).\n        const computedStyle = window.getComputedStyle(node);\n        if (computedStyle.display === 'none' && type !== 'hidden') {\n            active = 0;\n        } else {\n            active = isDisabled ? 0 : 1;\n        }\n\n        // Determine visual visibility based on computed styles.\n        const isVisuallyVisible = getElementVisualVisibility(node, computedStyle);\n\n        // Check for Moodle-specific _enabled checkbox dependencies (legacy support).\n        const enabledDependency = checkEnabledDependency(node);\n        if (enabledDependency) {\n            dependsOnEnabled = enabledDependency.checkboxName;\n            // If the controlling _enabled checkbox is not checked, mark element as inactive.\n            if (!enabledDependency.isEnabled) {\n                active = 0;\n            }\n        }\n\n        // Analyze all possible dependencies (select-based, checkbox-based, radio-based).\n        const allDependencies = checkElementDependencies(node);\n\n        // Analyze JavaScript-based dependencies (CSS classes, event handlers).\n        const jsDependencies = analyzeJavaScriptDependencies(node);\n\n        // Analyze relationships with sibling elements (similar names, numeric series).\n        const siblingDependencies = analyzeSiblingDependencies(node);\n\n        // Build the element data object with all extracted information.\n        const elementData = {\n            id: node.id || '',\n            name: node.name || '',\n            type: type,\n            current_value: currentValue,\n            label: label,\n            helptext: helptext,\n            active: active,\n            visible: isVisuallyVisible\n        };\n\n        // Add error text if present.\n        if (errorText) {\n            elementData.error_message = errorText;\n        }\n\n        // Add checked status for checkbox and radio elements.\n        if (type === 'checkbox' || type === 'radio') {\n            elementData.checked = node.checked || false;\n        }\n\n        // Add legacy _enabled dependency information if present.\n        if (dependsOnEnabled) {\n            elementData.depends_on_enabled = dependsOnEnabled;\n        }\n\n        // Add comprehensive dependency analysis if any dependencies were found.\n        if (allDependencies) {\n            elementData.dependencies = allDependencies;\n        }\n\n        // Add JavaScript-based dependency information if detected.\n        if (jsDependencies) {\n            elementData.js_dependencies = jsDependencies;\n        }\n\n        // Add sibling relationship information if similar elements were found.\n        if (siblingDependencies) {\n            elementData.sibling_dependencies = siblingDependencies;\n        }\n\n        // Add select options only for select elements (excluding verbose date/time selects).\n        if (type === 'select' && options.length > 0) {\n            elementData.options = options;\n        }\n\n        // Add the processed element to the collection.\n        elements.push(elementData);\n    });\n\n    // Extract page context from h2 headings with help information and add as elements\n    const pageContextElements = extractPageContext(contentDiv);\n    elements.push(...pageContextElements);\n\n    return elements;\n};\n\n/**\n * Extract documentation links from the current page.\n *\n * This function extracts all documentation links from h2 help content and footer support links.\n * It can be called independently from dialog.js to get page documentation context.\n *\n * @returns {Array} Array of documentation link objects containing url, linkText, and source information\n */\nexport const extractPageDock = () => {\n    const docLinks = [];\n\n    // Find the main content container\n    const contentDiv = document.getElementById('page-content');\n    if (!contentDiv) {\n        return docLinks;\n    }\n\n    // Extract links from h2 headings with help information\n    const headings = contentDiv.querySelectorAll('h2');\n    headings.forEach((heading) => {\n        const helpButton = heading.querySelector('a[data-bs-content]');\n        \n        if (helpButton && helpButton.getAttribute('data-bs-content')) {\n            const rawHelp = helpButton.getAttribute('data-bs-content');\n            const headingText = getHeadingText(heading);\n            \n            if (rawHelp) {\n                const helpLinks = extractLinksFromContent(rawHelp);\n                helpLinks.forEach(linkInfo => {\n                    docLinks.push({\n                        url: linkInfo.url,\n                        linkText: linkInfo.linkText,\n                        source: 'h2_help',\n                        context: headingText\n                    });\n                });\n            }\n        }\n    });\n\n    // Extract footer support links\n    const footerSupportLink = contentDiv.querySelector('.footer-support-link a[href*=\"docs.moodle.org\"]');\n    if (footerSupportLink) {\n        const footerUrl = footerSupportLink.getAttribute('href');\n        const footerLinkText = (footerSupportLink.textContent || footerSupportLink.innerText || '').trim();\n        \n        if (footerUrl && footerUrl.includes('docs.moodle.org')) {\n            // Check if this URL is different from already extracted URLs\n            const existingUrls = docLinks.map(link => link.url);\n            \n            if (!existingUrls.includes(footerUrl)) {\n                docLinks.push({\n                    url: footerUrl,\n                    linkText: footerLinkText,\n                    source: 'footer_support',\n                    context: 'Documentation for this page'\n                });\n            }\n        }\n    }\n\n    return docLinks;\n};\n\n/**\n * Extract heading text without help button content.\n *\n * @param {HTMLElement} heading - The heading element\n * @returns {string} Clean heading text\n */\nconst getHeadingText = (heading) => {\n    const headingClone = heading.cloneNode(true);\n    const helpButtonClone = headingClone.querySelector('a[data-bs-content]');\n    if (helpButtonClone) {\n        helpButtonClone.remove();\n    }\n    return (headingClone.textContent || headingClone.innerText || '').trim();\n};\n\n/**\n * Extract page context information from h2 headings with help content.\n *\n * This function searches for h2 elements that contain help buttons with Bootstrap popover\n * data-bs-content attributes and extracts the help text as additional context elements.\n * It uses the shared extractPageDock() method to get documentation links.\n *\n * @param {HTMLElement} contentDiv - The content container to search within\n * @returns {Array} Array of page context elements in the same format as form elements\n */\nconst extractPageContext = (contentDiv) => {\n    const contextElements = [];\n\n    // Find all h2 elements that might contain help information\n    const headings = contentDiv.querySelectorAll('h2');\n\n    headings.forEach((heading) => {\n        // Look for help buttons with Bootstrap popover data within the heading\n        const helpButton = heading.querySelector('a[data-bs-content]');\n\n        if (helpButton && helpButton.getAttribute('data-bs-content')) {\n            // Extract the heading text (without the help button content)\n            const headingText = getHeadingText(heading);\n\n            // Extract help content from the popover data attribute\n            const rawHelp = helpButton.getAttribute('data-bs-content');\n            let helpText = '';\n\n            if (rawHelp) {\n                // Clean HTML content from the popover to get plain text\n                const tmpDiv = document.createElement('div');\n                tmpDiv.innerHTML = rawHelp;\n                helpText = (tmpDiv.textContent || tmpDiv.innerText || '').trim();\n            }\n\n            // Only add if we have both heading and help text\n            if (headingText && helpText) {\n                // Create element in the same format as form elements\n                const contextElement = {\n                    id: heading.id || '',\n                    name: 'page_context_' + (heading.id || 'heading_' + contextElements.length),\n                    type: 'page_context',\n                    current_value: '',\n                    label: headingText,\n                    helptext: helpText,\n                    active: 1,\n                    visible: 1\n                };\n\n                contextElements.push(contextElement);\n            }\n        }\n    });\n\n    return contextElements;\n};\n\n/**\n * Extracts link information from HTML content, specifically looking for links inside .helpdoclink divs\n *\n * @param {string} htmlContent - The HTML content to search for links\n * @returns {Array} Array of link objects containing url and linkText\n */\nfunction extractLinksFromContent(htmlContent) {\n    const linkInfo = [];\n    \n    if (!htmlContent) return linkInfo;\n    \n    try {\n        // Create a temporary DOM element to parse the HTML\n        const tmpDiv = document.createElement('div');\n        tmpDiv.innerHTML = htmlContent;\n        \n        // Look specifically for links inside elements with .helpdoclink class\n        const helpdocLinks = tmpDiv.querySelectorAll('.helpdoclink a');\n        \n        helpdocLinks.forEach(link => {\n            const url = link.getAttribute('href');\n            const linkText = (link.textContent || link.innerText || '').trim();\n            \n            if (url && !url.startsWith('#') && !url.startsWith('javascript:')) {\n                linkInfo.push({\n                    url: url,\n                    linkText: linkText\n                });\n            }\n        });\n        \n        // If no .helpdoclink links found, fall back to any external links\n        if (linkInfo.length === 0) {\n            const allLinks = tmpDiv.querySelectorAll('a[href]');\n            \n            allLinks.forEach(link => {\n                const url = link.getAttribute('href');\n                const linkText = (link.textContent || link.innerText || '').trim();\n                \n                // Only include external links (not anchors or javascript)\n                if (url && !url.startsWith('#') && !url.startsWith('javascript:') && \n                    (url.startsWith('http') || url.startsWith('https'))) {\n                    linkInfo.push({\n                        url: url,\n                        linkText: linkText\n                    });\n                }\n            });\n        }\n    } catch (e) {\n        console.warn('Error parsing HTML content for links:', e);\n    }\n    \n    return linkInfo;\n}\n\n/**\n * Find label text for a given form element.\n *\n * This function implements multiple strategies to locate label text for form elements,\n * following Moodle's form conventions and standard HTML practices.\n *\n * @param {HTMLElement} element - The form element to find a label for\n * @returns {string} The label text, or empty string if no label is found\n */\nconst findLabelForElement = (element) => {\n    let label = '';\n\n    // Strategy 1: Explicit label with for attribute pointing to element's ID.\n    // This is the most reliable method when elements have proper IDs.\n    if (element.id) {\n        const labelElement = document.querySelector(`label[for=\"${element.id}\"]`);\n        if (labelElement) {\n            label = labelElement.textContent || labelElement.innerText || '';\n            label = label.trim();\n        }\n    }\n\n    // Strategy 2: Parent label element that wraps the input.\n    // Some forms use <label><input></label> structure instead of for/id association.\n    if (!label) {\n        const parentLabel = element.closest('label');\n        if (parentLabel) {\n            label = parentLabel.textContent || parentLabel.innerText || '';\n            label = label.trim();\n        }\n    }\n\n    // Strategy 3: Moodle-specific form structure with Bootstrap classes.\n    // Moodle forms use .fitem containers with .col-form-label sections.\n    if (!label) {\n        const fitemDiv = element.closest('.fitem');\n        if (fitemDiv) {\n            // Look for labels in the Bootstrap form structure used by Moodle.\n            const labelDiv = fitemDiv.querySelector('.col-form-label label, .col-form-label p');\n            if (labelDiv) {\n                label = labelDiv.textContent || labelDiv.innerText || '';\n                label = label.trim();\n            }\n        }\n    }\n\n    // Strategy 4: Accessibility attributes as fallback.\n    // Use aria-label or title attributes when no visible label is found.\n    if (!label) {\n        label = element.getAttribute('aria-label') || element.getAttribute('title') || '';\n    }\n\n    return label;\n};\n\n/**\n * Find helptext for a given form element.\n *\n * Searches for help text associated with form elements, typically found in\n * Bootstrap popover data attributes in Moodle forms.\n *\n * @param {HTMLElement} element - The form element to find help text for\n * @returns {string} The help text content, or empty string if none is found\n */\nconst findHelptextForElement = (element) => {\n    let helptext = '';\n\n    // Define containers to search in hierarchical order from specific to general.\n    const searchContainers = [\n        element.parentElement,           // Direct parent first.\n        element.closest('.fitem'),       // Moodle form item container.\n        element.closest('.felement'),    // Moodle form element wrapper.\n        element.closest('.col-md-9')     // Bootstrap column containing the input.\n    ];\n\n    // Search each container for help content in Bootstrap popovers.\n    for (const container of searchContainers) {\n        if (container) {\n            // Look for help icons with Bootstrap popover data.\n            const helpAnchor = container.querySelector('a[data-bs-content]');\n            if (helpAnchor?.getAttribute('data-bs-content')) {\n                const rawHelp = helpAnchor.getAttribute('data-bs-content');\n\n                // Clean HTML content from the popover to get plain text.\n                const tmpDiv = document.createElement('div');\n                tmpDiv.innerHTML = rawHelp;\n                helptext = tmpDiv.textContent || tmpDiv.innerText || '';\n                helptext = helptext.trim();\n                break;\n            }\n        }\n    }\n\n    return helptext;\n};\n\n/**\n * Find error text for a given form element.\n *\n * Searches for error messages associated with form elements, typically found in\n * Bootstrap invalid-feedback divs or similar error containers in Moodle forms.\n *\n * @param {HTMLElement} element - The form element to find error text for\n * @returns {string} The error text content, or empty string if none is found\n */\nconst findErrorForElement = (element) => {\n    let errorText = '';\n\n    // Define containers to search in hierarchical order from specific to general.\n    const searchContainers = [\n        element.parentElement,           // Direct parent first.\n        element.closest('.fitem'),       // Moodle form item container.\n        element.closest('.felement'),    // Moodle form element wrapper.\n        element.closest('.col-md-9')     // Bootstrap column containing the input.\n    ];\n\n    // Search each container for error content.\n    for (const container of searchContainers) {\n        if (container) {\n            // Look for Bootstrap invalid-feedback divs.\n            const errorDiv = container.querySelector('.invalid-feedback, .form-control-feedback.invalid-feedback');\n            if (errorDiv && errorDiv.style.display !== 'none') {\n                errorText = (errorDiv.textContent || errorDiv.innerText || '').trim();\n                if (errorText) {\n                    break;\n                }\n            }\n\n            // Also look for general error messages in .error class.\n            if (!errorText) {\n                const errorSpan = container.querySelector('.error');\n                if (errorSpan) {\n                    errorText = (errorSpan.textContent || errorSpan.innerText || '').trim();\n                    if (errorText) {\n                        break;\n                    }\n                }\n            }\n\n            // Look for ARIA error messages.\n            if (!errorText) {\n                const ariaErrorId = element.getAttribute('aria-describedby');\n                if (ariaErrorId) {\n                    const ariaErrorElement = document.getElementById(ariaErrorId);\n                    if (ariaErrorElement) {\n                        errorText = (ariaErrorElement.textContent || ariaErrorElement.innerText || '').trim();\n                        if (errorText) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return errorText;\n};\n\n/**\n * Check if an element depends on an _enabled checkbox.\n *\n * This function implements Moodle's convention where form elements can be controlled\n * by associated _enabled checkboxes. This pattern is commonly used in assignment\n * plugins and other areas where features can be enabled/disabled.\n *\n * @param {HTMLElement} element - The form element to check for _enabled dependencies\n * @returns {Object|null} Object with checkboxName and isEnabled, or null if no dependency\n */\nconst checkEnabledDependency = (element) => {\n    const elementName = element.name || element.id || '';\n\n    // Define various patterns for _enabled checkbox naming conventions.\n    const patterns = [\n        // Direct match: element_name -> element_name_enabled.\n        `${elementName}_enabled`,\n        // Partial match: some_element_option -> some_element_enabled.\n        elementName.replace(/_[^_]+$/, '_enabled'),\n        // Group patterns: like allowsubmissionsfromdate[day] -> allowsubmissionsfromdate[enabled].\n        elementName.replace(/\\[[^\\]]+\\]$/, '[enabled]')\n    ];\n\n    // Generate additional patterns by analyzing element name structure.\n    const nameParts = elementName.split('_');\n    if (nameParts.length > 1) {\n        // Example: assignsubmission_file_maxfiles -> assignsubmission_file_enabled.\n        for (let i = nameParts.length - 1; i >= 2; i--) {\n            const baseName = nameParts.slice(0, i).join('_');\n            patterns.push(`${baseName}_enabled`);\n        }\n    }\n\n    // Define search containers in order of specificity.\n    const searchContainers = [\n        element.closest('.fitem'),       // Immediate form item container.\n        element.closest('fieldset'),     // Fieldset grouping.\n        element.closest('.fcontainer'),  // Form container.\n        document.getElementById('page-content')  // Page-wide search as fallback.\n    ];\n\n    // Search for _enabled checkboxes using generated patterns.\n    for (const enabledName of patterns) {\n        for (const container of searchContainers) {\n            if (!container) {\n                continue;\n            }\n\n            // Look for checkbox with matching name or ID.\n            let enabledCheckbox = container.querySelector(\n                'input[type=\"checkbox\"][name=\"' + enabledName + '\"], ' +\n                'input[type=\"checkbox\"][id*=\"' + enabledName.replace(/[\\[\\]]/g, '_') + '\"]'\n            );\n\n            if (enabledCheckbox) {\n                return {\n                    checkboxName: enabledName,\n                    checkboxId: enabledCheckbox.id,\n                    isEnabled: enabledCheckbox.checked\n                };\n            }\n        }\n    }\n\n    // Special handling for Moodle form groups like fgroup_id_submissionplugins.\n    let fitemContainer = element.closest('.fitem');\n    if (fitemContainer) {\n        let fgroupMatch = fitemContainer.id && fitemContainer.id.match(/^fgroup_id_(.+)$/);\n        if (fgroupMatch) {\n            // Search for related _enabled checkboxes within the same group.\n            let groupCheckboxes = fitemContainer.querySelectorAll('input[type=\"checkbox\"][name*=\"_enabled\"]');\n            for (let gc = 0; gc < groupCheckboxes.length; gc++) {\n                let groupCheckbox = groupCheckboxes[gc];\n                let checkboxName = groupCheckbox.name;\n\n                // Check if the element name matches the checkbox pattern.\n                if (elementName.indexOf(checkboxName.replace('_enabled', '')) === 0) {\n                    return {\n                        checkboxName: checkboxName,\n                        checkboxId: groupCheckbox.id,\n                        isEnabled: groupCheckbox.checked\n                    };\n                }\n            }\n        }\n    }\n\n    return null;\n};\n\n/**\n * Check if a select element is within a date_time container.\n *\n * Date/time fields in Moodle often have many select options (days, months, years, hours, minutes)\n * which would clutter the output. This function identifies such containers to exclude their options.\n *\n * @param {HTMLElement} element - The select element to check\n * @returns {boolean} True if the element is within a date_time container\n */\nconst isWithinDateTimeContainer = (element) => {\n    // Search for parent element with data-fieldtype=\"date_time\" attribute.\n    const dateTimeContainer = element.closest('[data-fieldtype=\"date_time\"]');\n    if (dateTimeContainer) {\n        return true;\n    }\n\n    // Additional search for fieldset with date_time fieldtype.\n    const fieldsetContainer = element.closest('fieldset[data-fieldtype=\"date_time\"]');\n    if (fieldsetContainer) {\n        return true;\n    }\n\n    // Search for div or other containers with date_time fieldtype.\n    const divContainer = element.closest('div[data-fieldtype=\"date_time\"]');\n    if (divContainer) {\n        return true;\n    }\n\n    return false;\n};\n\n/**\n * Check for element dependencies (select-based, checkbox-based, radio-based).\n *\n * This is the main dependency analysis function that orchestrates the detection of\n * relationships between form elements. It identifies when elements are controlled by\n * other elements (e.g., select values determining field visibility).\n *\n * @param {HTMLElement} element - The element to check for dependencies\n * @returns {Array|null} Array of dependency objects or null if no dependencies found\n */\nconst checkElementDependencies = (element) => {\n    const form = element.closest('form');\n    if (!form) {\n        return null;\n    }\n\n    const elementContainer = element.closest('.fitem');\n    const dependencies = [];\n\n    // Analyze the visibility status of the current element.\n    const visibility = getElementVisibility(element, elementContainer);\n\n    // Find all potential controlling elements within the same form.\n    const controllingElements = form.querySelectorAll('select, input[type=\"checkbox\"], input[type=\"radio\"]');\n\n    controllingElements.forEach((controlElement) => {\n        // Skip self-references and inactive controlling elements.\n        if (controlElement === element ||\n            controlElement.closest('[style*=\"display: none\"]') ||\n            controlElement.hasAttribute('disabled') ||\n            controlElement.disabled) {\n            return;\n        }\n\n        // Analyze the relationship between the current element and potential controller.\n        const dependency = analyzeElementDependency(element, controlElement, visibility);\n        if (dependency) {\n            dependencies.push(dependency);\n        }\n    });\n\n    return dependencies.length > 0 ? dependencies : null;\n};\n\n/**\n * Get element visibility status.\n *\n * Analyzes how an element is hidden or disabled, providing detailed information\n * about the method used to hide the element. This is crucial for understanding\n * dependency relationships.\n *\n * @param {HTMLElement} element - The element to check\n * @param {HTMLElement} container - The container element (.fitem)\n * @returns {Object} Visibility information including hide method and disabled state\n */\nconst getElementVisibility = (element, container) => {\n    let isHidden = false;\n    let hideMethod = 'none';\n\n    if (container) {\n        const style = container.style;\n        const hiddenAttr = container.hasAttribute('hidden');\n        const computedStyle = window.getComputedStyle(container);\n\n        // Check various methods of hiding elements.\n        if (style && style.display === 'none') {\n            isHidden = true;\n            hideMethod = 'style_display';\n        } else if (hiddenAttr) {\n            isHidden = true;\n            hideMethod = 'hidden_attribute';\n        } else if (computedStyle.display === 'none') {\n            isHidden = true;\n            hideMethod = 'computed_style';\n        } else if (computedStyle.visibility === 'hidden') {\n            isHidden = true;\n            hideMethod = 'visibility_hidden';\n        }\n    }\n\n    return {\n        isHidden: isHidden,\n        hideMethod: hideMethod,\n        isDisabled: element.disabled || element.hasAttribute('disabled')\n    };\n};\n\n/**\n * Analyze potential dependency between two elements.\n *\n * This function implements the core logic for detecting dependencies between elements\n * using multiple pattern recognition strategies. It examines naming conventions,\n * container relationships, and semantic associations.\n *\n * @param {HTMLElement} dependentElement - The potentially dependent element\n * @param {HTMLElement} controlElement - The potentially controlling element\n * @param {Object} visibility - Visibility status of dependent element\n * @returns {Object|null} Dependency object or null if no relationship is found\n */\nconst analyzeElementDependency = (dependentElement, controlElement, visibility) => {\n    const controlName = controlElement.name || '';\n    const controlType = controlElement.type || controlElement.tagName.toLowerCase();\n    const controlValue = getControlElementValue(controlElement);\n\n    const dependentName = dependentElement.name || '';\n    const dependentId = dependentElement.id || '';\n\n    // Apply multiple pattern recognition strategies to identify dependencies.\n\n    // Pattern 1: Numeric suffix dependencies (e.g., primer1, instructions1 depend on preset=1).\n    const numericDependency = checkNumericSuffixDependency(dependentName, dependentId, controlName, controlValue);\n    if (numericDependency) {\n        return createDependencyObject(controlElement, controlValue, numericDependency.requiredValue, visibility);\n    }\n\n    // Pattern 2: Semantic name dependencies (mode -> topic/story/activities).\n    const semanticDependency = checkSemanticDependency(dependentName, dependentId, controlName, controlValue);\n    if (semanticDependency) {\n        return createDependencyObject(controlElement, controlValue, semanticDependency.requiredValue, visibility);\n    }\n\n    // Pattern 3: Container-based dependencies using data attributes.\n    const containerDependency = checkContainerDependency(dependentElement, controlElement, controlValue);\n    if (containerDependency) {\n        return createDependencyObject(controlElement, controlValue, containerDependency.requiredValue, visibility);\n    }\n\n    // Pattern 4: Checkbox enable/disable dependencies.\n    const enableDependency = checkEnableDependency(dependentName, dependentId, controlName, controlValue, controlType);\n    if (enableDependency) {\n        return createDependencyObject(controlElement, controlValue, enableDependency.requiredValue, visibility);\n    }\n\n    return null;\n};\n\n/**\n * Check for numeric suffix dependencies (e.g., primer1, instructions1 depend on preset=1).\n *\n * This pattern recognition function identifies dependencies where elements with numeric\n * suffixes depend on select/radio values. Common in scenarios like question presets\n * where different numbered configurations are shown based on selection.\n *\n * @param {string} dependentName - Name of dependent element\n * @param {string} dependentId - ID of dependent element\n * @param {string} controlName - Name of control element\n * @param {string} controlValue - Value of control element\n * @returns {Object|null} Dependency info or null if no pattern matches\n */\nconst checkNumericSuffixDependency = (dependentName, dependentId, controlName, controlValue) => {\n    // Extract numeric suffix from dependent element name or ID.\n    const dependentMatch = dependentName.match(/^(.+?)(\\d+)$/) || dependentId.match(/^id_(.+?)(\\d+)$/);\n    if (!dependentMatch) {\n        return null;\n    }\n\n    const baseName = dependentMatch[1];\n    const number = dependentMatch[2];\n\n    // Normalize control element name for comparison.\n    const controlBaseName = controlName.replace(/^(id_)?/, '').replace(/_$/, '');\n\n    // Define common patterns for numeric dependencies in Moodle forms.\n    const commonPatterns = [\n        { control: 'preset', dependents: ['primer', 'instructions', 'example', 'template', 'config'] },\n        { control: 'mode', dependents: ['option', 'setting', 'param', 'field'] },\n        { control: 'type', dependents: ['config', 'option', 'param', 'setting'] },\n        { control: 'category', dependents: ['subcategory', 'item', 'field'] },\n        { control: 'level', dependents: ['detail', 'item', 'option'] }\n    ];\n\n    // Check if the control and dependent names match any known patterns.\n    for (let i = 0; i < commonPatterns.length; i++) {\n        const pattern = commonPatterns[i];\n        if (controlBaseName === pattern.control && pattern.dependents.indexOf(baseName) !== -1) {\n            // The dependency exists if the number matches the control value.\n            if (number === controlValue) {\n                return { requiredValue: controlValue };\n            }\n        }\n    }\n\n    return null;\n};\n\n/**\n * Check for semantic name dependencies.\n *\n * This function identifies dependencies based on semantic relationships between\n * element names, where certain fields are shown/hidden based on mode selections\n * or similar conceptual groupings.\n *\n * @param {string} dependentName - Name of dependent element\n * @param {string} dependentId - ID of dependent element\n * @param {string} controlName - Name of control element\n * @param {string} controlValue - Value of control element\n * @returns {Object|null} Dependency info or null if no semantic relationship found\n */\nconst checkSemanticDependency = (dependentName, dependentId, controlName, controlValue) => {\n    // Define semantic mappings between control values and dependent field names.\n    const semanticMappings = {\n        'mode': {\n            '1': ['topic', 'subject', 'theme'],\n            '2': ['content', 'story', 'text', 'material'],\n            '3': ['activities', 'courseactivities', 'course_content', 'modules']\n        },\n        'type': {\n            'manual': ['manual_config', 'manual_settings'],\n            'auto': ['auto_config', 'auto_settings'],\n            'custom': ['custom_config', 'custom_settings']\n        },\n        'format': {\n            'html': ['html_editor', 'wysiwyg'],\n            'plain': ['plain_text', 'textarea'],\n            'markdown': ['markdown_editor']\n        }\n    };\n\n    const controlBaseName = controlName.replace(/^(id_)?/, '');\n    const dependentBaseName = dependentName.replace(/^(id_)?/, '');\n\n    // Check if the control element and dependent element match semantic patterns.\n    if (semanticMappings[controlBaseName]) {\n        const valueMapping = semanticMappings[controlBaseName][controlValue];\n        if (valueMapping && valueMapping.indexOf(dependentBaseName) !== -1) {\n            return { requiredValue: controlValue };\n        }\n    }\n\n    return null;\n};\n\n/**\n * Check for container-based dependencies using data attributes.\n *\n * This function looks for explicit dependency declarations in HTML data attributes,\n * which provide a standardized way to declare element relationships in forms.\n *\n * @param {HTMLElement} dependentElement - The dependent element\n * @param {HTMLElement} controlElement - The control element\n * @param {string} controlValue - Value of control element\n * @returns {Object|null} Dependency info or null if no data attributes found\n */\nconst checkContainerDependency = (dependentElement, controlElement, controlValue) => {\n    const container = dependentElement.closest('.fitem');\n    if (!container) {\n        return null;\n    }\n\n    // Check for data-depends-on attribute pointing to the control element.\n    const dependsOn = container.getAttribute('data-depends-on');\n    if (dependsOn === controlElement.name || dependsOn === controlElement.id) {\n        const showWhen = container.getAttribute('data-show-when') || controlValue;\n        return { requiredValue: showWhen };\n    }\n\n    // Check for data-conditional attribute with JSON configuration.\n    const conditional = container.getAttribute('data-conditional');\n    if (conditional) {\n        try {\n            const conditionObj = JSON.parse(conditional);\n            if (conditionObj.element === controlElement.name && conditionObj.value === controlValue) {\n                return { requiredValue: controlValue };\n            }\n        } catch (e) {\n            // Silently ignore JSON parse errors to prevent script breaking.\n        }\n    }\n\n    return null;\n};\n\n/**\n * Check for enable/disable checkbox dependencies.\n *\n * Identifies checkboxes that control the enabled/disabled state of other form elements.\n * This is different from visibility dependencies and focuses on form interaction state.\n *\n * @param {string} dependentName - Name of dependent element\n * @param {string} dependentId - ID of dependent element\n * @param {string} controlName - Name of control element\n * @param {string} controlValue - Value of control element\n * @param {string} controlType - Type of control element\n * @returns {Object|null} Dependency info or null if no enable pattern matches\n */\nconst checkEnableDependency = (dependentName, dependentId, controlName, controlValue, controlType) => {\n    if (controlType !== 'checkbox') {\n        return null;\n    }\n\n    // Define common patterns for enable/disable checkbox naming.\n    const patterns = [\n        dependentName + '_enabled',\n        dependentName + '_enable',\n        'enable_' + dependentName,\n        dependentName.replace(/^id_/, '') + '_enabled'\n    ];\n\n    if (patterns.indexOf(controlName) !== -1) {\n        return { requiredValue: '1' };\n    }\n\n    return null;\n};\n\n/**\n * Get value from control element (select, checkbox, radio).\n *\n * Extracts the current value from different types of form controls,\n * handling the specifics of each input type appropriately.\n *\n * @param {HTMLElement} element - The control element\n * @returns {string} The current value as a string\n */\nconst getControlElementValue = (element) => {\n    const type = element.type || element.tagName.toLowerCase();\n\n    if (type === 'checkbox' || type === 'radio') {\n        // For checkboxes and radios, return '1' if checked, '0' if unchecked.\n        return element.checked ? '1' : '0';\n    } else if (type === 'select' || type === 'select-one' || type === 'select-multiple') {\n        // For select elements, return the selected value.\n        return element.value || '';\n    } else {\n        // For all other input types, return the value directly.\n        return element.value || '';\n    }\n};\n\n/**\n * Create standardized dependency object.\n *\n * This function creates a consistent structure for dependency information\n * that can be used by AI systems to understand form element relationships.\n *\n * @param {HTMLElement} controlElement - The controlling element\n * @param {string} controlValue - Current value of controlling element\n * @param {string} requiredValue - Required value for visibility/enablement\n * @param {Object} visibility - Visibility status object\n * @returns {Object} Standardized dependency object\n */\nconst createDependencyObject = (controlElement, controlValue, requiredValue, visibility) => {\n    return {\n        controllingElement: controlElement.name || '',\n        controllingElementId: controlElement.id || '',\n        controllingType: controlElement.type || controlElement.tagName.toLowerCase(),\n        controllingValue: controlValue,\n        requiredValue: requiredValue,\n        isCurrentlyVisible: !visibility.isHidden && controlValue === requiredValue,\n        hideMethod: visibility.hideMethod\n    };\n};\n\n/**\n * Enhanced dependency analysis that also checks for common JavaScript patterns.\n *\n * This function analyzes CSS classes and JavaScript event handlers to identify\n * additional dependency patterns that may not be captured by DOM structure alone.\n *\n * @param {HTMLElement} element - The element to analyze\n * @returns {Array|null} Array of JavaScript dependency objects or null\n */\nconst analyzeJavaScriptDependencies = (element) => {\n    const container = element.closest('.fitem');\n    if (!container) {\n        return null;\n    }\n\n    const dependencies = [];\n\n    // Analyze CSS classes that indicate dependencies.\n    const classes = container.className.split(' ');\n    classes.forEach((cls) => {\n        // Pattern: depends-on-fieldname, show-when-fieldname-value.\n        if (cls.startsWith('depends-on-')) {\n            const dependencyName = cls.replace('depends-on-', '');\n            dependencies.push({\n                type: 'css_class',\n                pattern: cls,\n                dependsOn: dependencyName\n            });\n        } else if (cls.match(/^show-when-\\w+-\\w+$/)) {\n            const parts = cls.replace('show-when-', '').split('-');\n            if (parts.length >= 2) {\n                dependencies.push({\n                    type: 'css_class',\n                    pattern: cls,\n                    dependsOn: parts[0],\n                    requiredValue: parts.slice(1).join('-')\n                });\n            }\n        }\n    });\n\n    // Prüfe Event-Handler, die auf Änderungen reagieren\n    const form = element.closest('form');\n    if (form) {\n        const scripts = document.querySelectorAll('script');\n        scripts.forEach((script) => {\n            const content = script.textContent || script.innerText;\n            if (content && content.includes(element.name || element.id)) {\n                // Suche nach Event-Handler-Patterns\n                const eventPatterns = [\n                    /addEventListener\\(['\"]change['\"],\\s*function/g,\n                    /\\.on\\(['\"]change['\"],\\s*function/g,\n                    /onchange\\s*=\\s*['\"]?[^'\"]+/g\n                ];\n\n                eventPatterns.forEach((pattern) => {\n                    if (content.match(pattern)) {\n                        dependencies.push({\n                            type: 'javascript_event',\n                            pattern: 'change_listener',\n                            element: element.name || element.id\n                        });\n                    }\n                });\n            }\n        });\n    }\n\n    return dependencies.length > 0 ? dependencies : null;\n};\n\n/**\n * Analyze sibling and parent-child dependencies within form groups.\n *\n * @param {HTMLElement} element - The element to analyze\n * @returns {Object|null} Sibling dependency information\n */\nconst analyzeSiblingDependencies = (element) => {\n    const container = element.closest('.fitem');\n    if (!container) {\n        return null;\n    }\n\n    const dependencies = [];\n    const elementName = element.name || '';\n\n    // Finde Geschwister-Container\n    const siblingContainers = [];\n    const parent = container.parentNode;\n    if (parent) {\n        const allFitems = parent.querySelectorAll('.fitem');\n        allFitems.forEach((fitem) => {\n            if (fitem !== container) {\n                siblingContainers.push(fitem);\n            }\n        });\n    }\n\n    // Analysiere Geschwister auf ähnliche Namen\n    siblingContainers.forEach((siblingContainer) => {\n        const siblingElements = siblingContainer.querySelectorAll('input, select, textarea');\n        siblingElements.forEach((siblingElement) => {\n            const siblingName = siblingElement.name || '';\n\n            // Pattern: Ähnliche Namen mit Suffixen/Präfixen\n            const similarity = analyzeSimilarity(elementName, siblingName);\n            if (similarity.score > 0.7 && similarity.type) {\n                const siblingVisibility = getElementVisibility(siblingElement, siblingContainer);\n\n                dependencies.push({\n                    type: 'sibling_dependency',\n                    siblingElement: siblingName,\n                    siblingId: siblingElement.id || '',\n                    similarity: similarity,\n                    siblingVisible: !siblingVisibility.isHidden\n                });\n            }\n        });\n    });\n\n    return dependencies.length > 0 ? dependencies : null;\n};\n\n/**\n * Analyze similarity between two element names.\n *\n * @param {string} name1 - First element name\n * @param {string} name2 - Second element name\n * @returns {Object} Similarity analysis\n */\nconst analyzeSimilarity = (name1, name2) => {\n    if (!name1 || !name2) {\n        return { score: 0, type: null };\n    }\n\n    // Entferne gemeinsame Präfixe\n    const cleanName1 = name1.replace(/^(id_)?/, '');\n    const cleanName2 = name2.replace(/^(id_)?/, '');\n\n    // Pattern 1: Numerische Suffixe (field1, field2, field3)\n    const numPattern1 = cleanName1.match(/^(.+?)(\\d+)$/);\n    const numPattern2 = cleanName2.match(/^(.+?)(\\d+)$/);\n\n    if (numPattern1 && numPattern2 && numPattern1[1] === numPattern2[1]) {\n        return {\n            score: 0.9,\n            type: 'numeric_series',\n            basePattern: numPattern1[1],\n            numbers: [numPattern1[2], numPattern2[2]]\n        };\n    }\n\n    // Pattern 2: Ähnliche Basis mit verschiedenen Suffixen\n    let commonPrefixLength = 0;\n    for (let i = 0; i < Math.min(cleanName1.length, cleanName2.length); i++) {\n        if (cleanName1[i] === cleanName2[i]) {\n            commonPrefixLength++;\n        } else {\n            break;\n        }\n    }\n\n    if (commonPrefixLength >= 3) {\n        const similarity = commonPrefixLength / Math.max(cleanName1.length, cleanName2.length);\n        return {\n            score: similarity,\n            type: 'similar_prefix',\n            commonPrefix: cleanName1.substring(0, commonPrefixLength)\n        };\n    }\n\n    return { score: 0, type: null };\n};\n\n/**\n * Determine visual visibility of an element based on computed styles.\n *\n * This function analyzes the computed CSS styles to determine if an element\n * is visually visible to the user. It checks multiple CSS properties that\n * can affect visibility including display, visibility, opacity, and dimensions.\n * It also traverses up the DOM tree to check if any parent elements are hidden.\n *\n * @param {HTMLElement} element - The element to check for visual visibility\n * @param {CSSStyleDeclaration} computedStyle - Optional pre-computed style object\n * @returns {boolean} True if the element is visually visible, false otherwise\n */\nconst getElementVisualVisibility = (element, computedStyle) => {\n    // First check if the element itself is hidden by any method.\n    if (!isElementDirectlyVisible(element, computedStyle)) {\n        return false;\n    }\n\n    // Then check if any parent element is hidden.\n    return !hasHiddenParent(element);\n};\n\n/**\n * Check if an element is directly visible (ignoring parent visibility).\n *\n * @param {HTMLElement} element - The element to check\n * @param {CSSStyleDeclaration} computedStyle - Optional pre-computed style object\n * @returns {boolean} True if the element itself is visible\n */\nconst isElementDirectlyVisible = (element, computedStyle) => {\n    // Check for hidden attribute.\n    if (element.hasAttribute('hidden')) {\n        return false;\n    }\n\n    // Use provided computed style or calculate it.\n    const styles = computedStyle || window.getComputedStyle(element);\n\n    // Check if element is hidden via display property.\n    if (styles.display === 'none') {\n        return false;\n    }\n\n    // Check if element is hidden via visibility property.\n    if (styles.visibility === 'hidden') {\n        return false;\n    }\n\n    // Check if element is transparent (opacity 0).\n    const opacity = parseFloat(styles.opacity);\n    if (opacity === 0) {\n        return false;\n    }\n\n    // Check if element has zero dimensions (width or height).\n    const width = parseFloat(styles.width);\n    const height = parseFloat(styles.height);\n    if (width === 0 && height === 0) {\n        return false;\n    }\n\n    // Check if element is clipped to invisible area.\n    const clip = styles.clip;\n    if (clip && clip !== 'auto' && clip.match(/rect\\(0px,?\\s*0px,?\\s*0px,?\\s*0px\\)/)) {\n        return false;\n    }\n\n    // Check if element is positioned offscreen.\n    const position = styles.position;\n    if (position === 'absolute' || position === 'fixed') {\n        const left = parseFloat(styles.left);\n        const top = parseFloat(styles.top);\n        const right = parseFloat(styles.right);\n        const bottom = parseFloat(styles.bottom);\n\n        // Common patterns for hiding elements offscreen.\n        if ((left < -9999 || right < -9999 || top < -9999 || bottom < -9999) ||\n            (left > 9999 || right > 9999 || top > 9999 || bottom > 9999)) {\n        }\n    }\n\n    // Check for text-indent hiding technique.\n    const textIndent = parseFloat(styles.textIndent);\n    if (textIndent < -9999 || textIndent > 9999) {\n        return false;\n    }\n\n    return true;\n};\n\n/**\n * Check if any parent element is hidden.\n *\n * Since we now wait for all JavaScript to execute before analyzing the DOM,\n * we can rely on the current computed styles to accurately reflect visibility.\n *\n * @param {HTMLElement} element - The element whose parents to check\n * @returns {boolean} True if any parent is hidden, false otherwise\n */\nconst hasHiddenParent = (element) => {\n    let parent = element.parentElement;\n\n    while (parent && parent !== document.body && parent !== document.documentElement) {\n        // Check for hidden attribute on parent elements.\n        if (parent.hasAttribute('hidden') || parent.hidden === true) {\n            return true;\n        }\n\n        // Check computed styles of parent elements.\n        const parentStyles = window.getComputedStyle(parent);\n        if (parentStyles.display === 'none' || parentStyles.visibility === 'hidden') {\n            return true;\n        }\n\n        // Check for opacity 0 on parent elements.\n        const parentOpacity = parseFloat(parentStyles.opacity);\n        if (parentOpacity === 0) {\n            return true;\n        }\n\n        parent = parent.parentElement;\n    }\n\n    return false;\n};\n"],"names":["elements","contentDiv","document","getElementById","querySelectorAll","forEach","node","type","tagName","toLowerCase","currentValue","options","checked","value","style","display","id","tinyFrame","querySelector","contentDocument","tinyBody","body","textContent","innerText","e","selectedOptions","length","isWithinDateTimeContainer","option","push","text","selected","label","findLabelForElement","helptext","findHelptextForElement","errorText","findErrorForElement","active","isDisabled","dependsOnEnabled","disabled","attrNode","getAttributeNode","_node$getAttributeNod","specified","computedStyle","window","getComputedStyle","isVisuallyVisible","getElementVisualVisibility","enabledDependency","checkEnabledDependency","checkboxName","isEnabled","allDependencies","checkElementDependencies","jsDependencies","analyzeJavaScriptDependencies","siblingDependencies","analyzeSiblingDependencies","elementData","name","current_value","visible","error_message","depends_on_enabled","dependencies","js_dependencies","sibling_dependencies","pageContextElements","extractPageContext","docLinks","heading","helpButton","getAttribute","rawHelp","headingText","getHeadingText","htmlContent","linkInfo","tmpDiv","createElement","innerHTML","link","url","linkText","trim","startsWith","console","warn","extractLinksFromContent","source","context","footerSupportLink","footerUrl","footerLinkText","includes","map","headingClone","cloneNode","helpButtonClone","remove","contextElements","helpText","contextElement","element","labelElement","parentLabel","closest","fitemDiv","labelDiv","searchContainers","parentElement","container","helpAnchor","errorDiv","errorSpan","ariaErrorId","ariaErrorElement","elementName","patterns","replace","nameParts","split","i","baseName","slice","join","enabledName","enabledCheckbox","checkboxId","fitemContainer","match","groupCheckboxes","gc","groupCheckbox","indexOf","form","elementContainer","visibility","getElementVisibility","controlElement","hasAttribute","dependency","analyzeElementDependency","isHidden","hideMethod","hiddenAttr","dependentElement","controlName","controlType","controlValue","getControlElementValue","dependentName","dependentId","numericDependency","checkNumericSuffixDependency","createDependencyObject","requiredValue","semanticDependency","checkSemanticDependency","containerDependency","checkContainerDependency","enableDependency","checkEnableDependency","dependentMatch","number","controlBaseName","commonPatterns","control","dependents","pattern","semanticMappings","dependentBaseName","valueMapping","dependsOn","conditional","conditionObj","JSON","parse","controllingElement","controllingElementId","controllingType","controllingValue","isCurrentlyVisible","className","cls","dependencyName","parts","script","content","siblingContainers","parent","parentNode","fitem","siblingContainer","siblingElement","siblingName","similarity","analyzeSimilarity","score","siblingVisibility","siblingId","siblingVisible","name1","name2","cleanName1","cleanName2","numPattern1","numPattern2","basePattern","numbers","commonPrefixLength","Math","min","max","commonPrefix","substring","isElementDirectlyVisible","hasHiddenParent","styles","parseFloat","opacity","width","height","clip","position","left","top","right","bottom","textIndent","documentElement","hidden","parentStyles"],"mappings":"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"}