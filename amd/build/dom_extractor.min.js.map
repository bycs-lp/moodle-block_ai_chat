{"version":3,"file":"dom_extractor.min.js","sources":["../src/dom_extractor.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Extract DOM elements and export them as JSON.\n *\n * @module     block_ai_chat/dom_extractor\n * @copyright  2025 ISB Bayern\n * @author     Dr. Peter Mayer\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/**\n * Get DOM elements inside #page-content and return as JSON.\n *\n * This function scans the page content for form elements and extracts their properties,\n * including values, labels, help text, error messages, and complex dependencies between elements.\n * It supports all major form input types and analyzes their relationships.\n * Additionally, it extracts page context information from h2 headings with help content as additional elements.\n *\n * @returns {Array} Array containing structured form element data with dependencies and page context elements\n */\nexport const extractDomElements = () => {\n    const elements = [];\n\n    // Find the main content container - all Moodle forms are within #page-content.\n    const contentDiv = document.getElementById('page-content');\n    if (!contentDiv) {\n        // Return empty structure if no content area is found.\n        return [];\n    }\n\n    // Comprehensive selector for all form input types including hidden fields and buttons.\n    // This covers standard inputs, textareas, selects, and special Moodle form elements.\n    const selector =\n        'input[type=\"text\"], input[type=\"password\"], input[type=\"email\"], input[type=\"number\"], ' +\n        'input[type=\"search\"], input[type=\"tel\"], input[type=\"url\"], input[type=\"date\"], ' +\n        'input[type=\"datetime-local\"], input[type=\"checkbox\"], input[type=\"radio\"], input[type=\"file\"], ' +\n        'input[type=\"hidden\"], input[type=\"submit\"], input[type=\"button\"], textarea, select';\n\n    const domNodes = contentDiv.querySelectorAll(selector);\n\n    // Process each form element found in the DOM.\n    // eslint-disable-next-line complexity\n    domNodes.forEach((node) => {\n        let type = node.tagName.toLowerCase();\n        let currentValue = '';\n        const options = [];\n\n        // Extract current value based on element type and special handling for different inputs.\n        if (type === 'input') {\n            type = node.type;\n            if (type === 'checkbox' || type === 'radio') {\n                // For checkboxes and radios, return the value only if checked, otherwise empty.\n                currentValue = node.checked ? node.value || 'on' : '';\n            } else {\n                // For all other input types, get the current value.\n                currentValue = node.value || '';\n            }\n        } else if (type === 'textarea') {\n            type = 'textarea';\n\n            // Special handling for TinyMCE editors which are hidden textareas with iframe content.\n            if (node.style.display === 'none' && node.id) {\n                const tinyFrame = document.querySelector(`#${node.id}_ifr`);\n                if (tinyFrame?.contentDocument) {\n                    try {\n                        // Extract content from TinyMCE iframe body.\n                        const tinyBody = tinyFrame.contentDocument.body;\n                        currentValue = tinyBody ? (tinyBody.textContent || tinyBody.innerText || '') : node.value || '';\n                    } catch (e) {\n                        // Fallback to textarea value if iframe access fails (cross-origin issues).\n                        currentValue = node.value || '';\n                    }\n                } else {\n                    currentValue = node.value || '';\n                }\n            } else {\n                // Standard textarea handling.\n                currentValue = node.value || '';\n            }\n        } else if (type === 'select') {\n            type = 'select';\n\n            // Get selected value from select element.\n            currentValue = node.selectedOptions?.length > 0 ? node.selectedOptions[0].value : (node.value || '');\n\n            // Check if this select is within a date_time container to avoid verbose output.\n            if (!isWithinDateTimeContainer(node)) {\n                const optionElements = node.querySelectorAll('option');\n                optionElements.forEach((option) => {\n                    options.push({\n                        value: option.value,\n                        text: option.textContent || option.innerText || '',\n                        selected: option.selected\n                    });\n                });\n            }\n        }\n\n        // Find the associated label text using multiple strategies for Moodle form conventions.\n        const label = findLabelForElement(node);\n\n        // Extract help text/description that provides additional context for the field.\n        const helptext = findHelptextForElement(node);\n\n        // Extract error text/validation messages for the field.\n        const errorText = findErrorForElement(node);\n\n        // Determine if the element is currently active/enabled (1) or disabled (0).\n        let active = 1;\n        let isDisabled = false;\n        let dependsOnEnabled = null;\n\n        // Check element disabled state using multiple methods to ensure compatibility.\n        // Method 1: Check the disabled property directly.\n        if (node.disabled === true) {\n            isDisabled = true;\n        }\n\n        // Method 2: Check for disabled attribute (covers cases like <select disabled> and <select disabled=\"disabled\">).\n        const attrNode = node.getAttributeNode?.('disabled');\n        if (attrNode?.specified) {\n            isDisabled = true;\n        }\n\n        // Check if element is hidden via CSS styles (but not for hidden input types).\n        const computedStyle = window.getComputedStyle(node);\n        if (computedStyle.display === 'none' && type !== 'hidden') {\n            active = 0;\n        } else {\n            active = isDisabled ? 0 : 1;\n        }\n\n        // Determine visual visibility based on computed styles.\n        const isVisuallyVisible = getElementVisualVisibility(node, computedStyle);\n\n        // Check for Moodle-specific _enabled checkbox dependencies (legacy support).\n        const enabledDependency = checkEnabledDependency(node);\n        if (enabledDependency) {\n            dependsOnEnabled = enabledDependency.checkboxName;\n            // If the controlling _enabled checkbox is not checked, mark element as inactive.\n            if (!enabledDependency.isEnabled) {\n                active = 0;\n            }\n        }\n\n        // Analyze all possible dependencies (select-based, checkbox-based, radio-based).\n        const allDependencies = checkElementDependencies(node);\n\n        // Analyze JavaScript-based dependencies (CSS classes, event handlers).\n        const jsDependencies = analyzeJavaScriptDependencies(node);\n\n        // Analyze relationships with sibling elements (similar names, numeric series).\n        const siblingDependencies = analyzeSiblingDependencies(node);\n\n        // Build the element data object with all extracted information.\n        const elementData = {\n            id: node.id || '',\n            name: node.name || '',\n            type: type,\n            currentValue: currentValue,\n            label: label,\n            helptext: helptext,\n            active: active,\n            visible: isVisuallyVisible\n        };\n\n        // Add error text if present.\n        if (errorText) {\n            elementData.errorMessage = errorText;\n        }\n\n        // Add checked status for checkbox and radio elements.\n        if (type === 'checkbox' || type === 'radio') {\n            elementData.checked = node.checked || false;\n        }\n\n        // Add legacy _enabled dependency information if present.\n        if (dependsOnEnabled) {\n            elementData.dependsOnEnabled = dependsOnEnabled;\n        }\n\n        // Add comprehensive dependency analysis if any dependencies were found.\n        if (allDependencies) {\n            elementData.dependencies = allDependencies;\n        }\n\n        // Add JavaScript-based dependency information if detected.\n        if (jsDependencies) {\n            elementData.jsDependencies = jsDependencies;\n        }\n\n        // Add sibling relationship information if similar elements were found.\n        if (siblingDependencies) {\n            elementData.siblingDependencies = siblingDependencies;\n        }\n\n        // Add select options only for select elements (excluding verbose date/time selects).\n        if (type === 'select' && options.length > 0) {\n            elementData.options = options;\n        }\n\n        // Add the processed element to the collection.\n        elements.push(elementData);\n    });\n\n    // Extract page context from h2 headings with help information and add as elements\n    const pageContextElements = extractPageContext(contentDiv);\n    elements.push(...pageContextElements);\n\n    return elements;\n};\n\n/**\n * Extract heading text without help button content.\n *\n * @param {HTMLElement} heading - The heading element\n * @returns {string} Clean heading text\n */\nconst getHeadingText = (heading) => {\n    const headingClone = heading.cloneNode(true);\n    const helpButtonClone = headingClone.querySelector('a[data-bs-content]');\n    if (helpButtonClone) {\n        helpButtonClone.remove();\n    }\n    return (headingClone.textContent || headingClone.innerText || '').trim();\n};\n\n/**\n * Extract page context information from h2 headings with help content.\n *\n * This function searches for h2 elements that contain help buttons with Bootstrap popover\n * data-bs-content attributes and extracts the help text as additional context elements.\n * It uses the shared extractPageDock() method to get documentation links.\n *\n * @param {HTMLElement} contentDiv - The content container to search within\n * @returns {Array} Array of page context elements in the same format as form elements\n */\nconst extractPageContext = (contentDiv) => {\n    const contextElements = [];\n\n    // Find all h2 elements that might contain help information\n    const headings = contentDiv.querySelectorAll('h2');\n\n    headings.forEach((heading) => {\n        // Look for help buttons with Bootstrap popover data within the heading\n        const helpButton = heading.querySelector('a[data-bs-content]');\n\n        if (helpButton && helpButton.getAttribute('data-bs-content')) {\n            // Extract the heading text (without the help button content)\n            const headingText = getHeadingText(heading);\n\n            // Extract help content from the popover data attribute\n            const rawHelp = helpButton.getAttribute('data-bs-content');\n            let helpText = '';\n\n            if (rawHelp) {\n                // Clean HTML content from the popover to get plain text\n                const tmpDiv = document.createElement('div');\n                tmpDiv.innerHTML = rawHelp;\n                helpText = (tmpDiv.textContent || tmpDiv.innerText || '').trim();\n            }\n\n            // Only add if we have both heading and help text\n            if (headingText && helpText) {\n                // Create element in the same format as form elements\n                const contextElement = {\n                    id: heading.id || '',\n                    name: 'page_context_' + (heading.id || 'heading_' + contextElements.length),\n                    type: 'page_context',\n                    currentValue: '',\n                    label: headingText,\n                    helptext: helpText,\n                    active: 1,\n                    visible: 1\n                };\n\n                contextElements.push(contextElement);\n            }\n        }\n    });\n\n    return contextElements;\n};\n\n/**\n * Find label text for a given form element.\n *\n * This function implements multiple strategies to locate label text for form elements,\n * following Moodle's form conventions and standard HTML practices.\n *\n * @param {HTMLElement} element - The form element to find a label for\n * @returns {string} The label text, or empty string if no label is found\n */\nconst findLabelForElement = (element) => {\n    let label = '';\n\n    // Strategy 1: Explicit label with for attribute pointing to element's ID.\n    // This is the most reliable method when elements have proper IDs.\n    if (element.id) {\n        const labelElement = document.querySelector(`label[for=\"${element.id}\"]`);\n        if (labelElement) {\n            label = labelElement.textContent || labelElement.innerText || '';\n            label = label.trim();\n        }\n    }\n\n    // Strategy 2: Parent label element that wraps the input.\n    // Some forms use <label><input></label> structure instead of for/id association.\n    if (!label) {\n        const parentLabel = element.closest('label');\n        if (parentLabel) {\n            label = parentLabel.textContent || parentLabel.innerText || '';\n            label = label.trim();\n        }\n    }\n\n    // Strategy 3: Moodle-specific form structure with Bootstrap classes.\n    // Moodle forms use .fitem containers with .col-form-label sections.\n    if (!label) {\n        const fitemDiv = element.closest('.fitem');\n        if (fitemDiv) {\n            // Look for labels in the Bootstrap form structure used by Moodle.\n            const labelDiv = fitemDiv.querySelector('.col-form-label label, .col-form-label p');\n            if (labelDiv) {\n                label = labelDiv.textContent || labelDiv.innerText || '';\n                label = label.trim();\n            }\n        }\n    }\n\n    // Strategy 4: Accessibility attributes as fallback.\n    // Use aria-label or title attributes when no visible label is found.\n    if (!label) {\n        label = element.getAttribute('aria-label') || element.getAttribute('title') || '';\n    }\n\n    return label;\n};\n\n/**\n * Find helptext for a given form element.\n *\n * Searches for help text associated with form elements, typically found in\n * Bootstrap popover data attributes in Moodle forms.\n *\n * @param {HTMLElement} element - The form element to find help text for\n * @returns {string} The help text content, or empty string if none is found\n */\nconst findHelptextForElement = (element) => {\n    let helptext = '';\n\n    // Define containers to search in hierarchical order from specific to general.\n    const searchContainers = [\n        element.parentElement, // Direct parent first.\n        element.closest('.fitem'), // Moodle form item container.\n        element.closest('.felement'), // Moodle form element wrapper.\n        element.closest('.col-md-9') // Bootstrap column containing the input.\n    ];\n\n    // Search each container for help content in Bootstrap popovers.\n    for (const container of searchContainers) {\n        if (container) {\n            // Look for help icons with Bootstrap popover data.\n            const helpAnchor = container.querySelector('a[data-bs-content]');\n            if (helpAnchor?.getAttribute('data-bs-content')) {\n                const rawHelp = helpAnchor.getAttribute('data-bs-content');\n\n                // Clean HTML content from the popover to get plain text.\n                const tmpDiv = document.createElement('div');\n                tmpDiv.innerHTML = rawHelp;\n                helptext = tmpDiv.textContent || tmpDiv.innerText || '';\n                helptext = helptext.trim();\n                break;\n            }\n        }\n    }\n\n    return helptext;\n};\n\n/**\n * Find error text for a given form element.\n *\n * Searches for error messages associated with form elements, typically found in\n * Bootstrap invalid-feedback divs or similar error containers in Moodle forms.\n *\n * @param {HTMLElement} element - The form element to find error text for\n * @returns {string} The error text content, or empty string if none is found\n */\nconst findErrorForElement = (element) => {\n    let errorText = '';\n\n    // Define containers to search in hierarchical order from specific to general.\n    const searchContainers = [\n        element.parentElement, // Direct parent first.\n        element.closest('.fitem'), // Moodle form item container.\n        element.closest('.felement'), // Moodle form element wrapper.\n        element.closest('.col-md-9') // Bootstrap column containing the input.\n    ];\n\n    // Search each container for error content.\n    for (const container of searchContainers) {\n        if (container) {\n            // Look for Bootstrap invalid-feedback divs.\n            const errorDiv = container.querySelector('.invalid-feedback, .form-control-feedback.invalid-feedback');\n            if (errorDiv && errorDiv.style.display !== 'none') {\n                errorText = (errorDiv.textContent || errorDiv.innerText || '').trim();\n                if (errorText) {\n                    break;\n                }\n            }\n\n            // Also look for general error messages in .error class.\n            if (!errorText) {\n                const errorSpan = container.querySelector('.error');\n                if (errorSpan) {\n                    errorText = (errorSpan.textContent || errorSpan.innerText || '').trim();\n                    // eslint-disable-next-line max-depth\n                    if (errorText) {\n                        break;\n                    }\n                }\n            }\n\n            // Look for ARIA error messages.\n            if (!errorText) {\n                const ariaErrorId = element.getAttribute('aria-describedby');\n                if (ariaErrorId) {\n                    const ariaErrorElement = document.getElementById(ariaErrorId);\n                    // eslint-disable-next-line max-depth\n                    if (ariaErrorElement) {\n                        errorText = (ariaErrorElement.textContent || ariaErrorElement.innerText || '').trim();\n                        // eslint-disable-next-line max-depth\n                        if (errorText) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return errorText;\n};\n\n/**\n * Check if an element depends on an _enabled checkbox.\n *\n * This function implements Moodle's convention where form elements can be controlled\n * by associated _enabled checkboxes. This pattern is commonly used in assignment\n * plugins and other areas where features can be enabled/disabled.\n *\n * @param {HTMLElement} element - The form element to check for _enabled dependencies\n * @returns {Object|null} Object with checkboxName and isEnabled, or null if no dependency\n */\nconst checkEnabledDependency = (element) => {\n    const elementName = element.name || element.id || '';\n\n    // Define various patterns for _enabled checkbox naming conventions.\n    const patterns = [\n        // Direct match: element_name -> element_name_enabled.\n        `${elementName}_enabled`,\n        // Partial match: some_element_option -> some_element_enabled.\n        elementName.replace(/_[^_]+$/, '_enabled'),\n        // Group patterns: like allowsubmissionsfromdate[day] -> allowsubmissionsfromdate[enabled].\n        elementName.replace(/\\[[^\\]]+\\]$/, '[enabled]')\n    ];\n\n    // Generate additional patterns by analyzing element name structure.\n    const nameParts = elementName.split('_');\n    if (nameParts.length > 1) {\n        // Example: assignsubmission_file_maxfiles -> assignsubmission_file_enabled.\n        for (let i = nameParts.length - 1; i >= 2; i--) {\n            const baseName = nameParts.slice(0, i).join('_');\n            patterns.push(`${baseName}_enabled`);\n        }\n    }\n\n    // Define search containers in order of specificity.\n    const searchContainers = [\n        element.closest('.fitem'), // Immediate form item container.\n        element.closest('fieldset'), // Fieldset grouping.\n        element.closest('.fcontainer'), // Form container.\n        document.getElementById('page-content') // Page-wide search as fallback.\n    ];\n\n    // Search for _enabled checkboxes using generated patterns.\n    for (const enabledName of patterns) {\n        for (const container of searchContainers) {\n            if (!container) {\n                continue;\n            }\n\n            // Look for checkbox with matching name or ID.\n            let enabledCheckbox = container.querySelector(\n                'input[type=\"checkbox\"][name=\"' + enabledName + '\"], ' +\n                'input[type=\"checkbox\"][id*=\"' + enabledName.replace(/[[\\]]/g, '_') + '\"]'\n            );\n\n            if (enabledCheckbox) {\n                return {\n                    checkboxName: enabledName,\n                    checkboxId: enabledCheckbox.id,\n                    isEnabled: enabledCheckbox.checked\n                };\n            }\n        }\n    }\n\n    // Special handling for Moodle form groups like fgroup_id_submissionplugins.\n    let fitemContainer = element.closest('.fitem');\n    if (fitemContainer) {\n        let fgroupMatch = fitemContainer.id && fitemContainer.id.match(/^fgroup_id_(.+)$/);\n        if (fgroupMatch) {\n            // Search for related _enabled checkboxes within the same group.\n            let groupCheckboxes = fitemContainer.querySelectorAll('input[type=\"checkbox\"][name*=\"_enabled\"]');\n            for (let gc = 0; gc < groupCheckboxes.length; gc++) {\n                let groupCheckbox = groupCheckboxes[gc];\n                let checkboxName = groupCheckbox.name;\n\n                // Check if the element name matches the checkbox pattern.\n                if (elementName.indexOf(checkboxName.replace('_enabled', '')) === 0) {\n                    return {\n                        checkboxName: checkboxName,\n                        checkboxId: groupCheckbox.id,\n                        isEnabled: groupCheckbox.checked\n                    };\n                }\n            }\n        }\n    }\n\n    return null;\n};\n\n/**\n * Check if a select element is within a date_time container.\n *\n * Date/time fields in Moodle often have many select options (days, months, years, hours, minutes)\n * which would clutter the output. This function identifies such containers to exclude their options.\n *\n * @param {HTMLElement} element - The select element to check\n * @returns {boolean} True if the element is within a date_time container\n */\nconst isWithinDateTimeContainer = (element) => {\n    // Search for parent element with data-fieldtype=\"date_time\" attribute.\n    const dateTimeContainer = element.closest('[data-fieldtype=\"date_time\"]');\n    if (dateTimeContainer) {\n        return true;\n    }\n\n    // Additional search for fieldset with date_time fieldtype.\n    const fieldsetContainer = element.closest('fieldset[data-fieldtype=\"date_time\"]');\n    if (fieldsetContainer) {\n        return true;\n    }\n\n    // Search for div or other containers with date_time fieldtype.\n    const divContainer = element.closest('div[data-fieldtype=\"date_time\"]');\n    if (divContainer) {\n        return true;\n    }\n\n    return false;\n};\n\n/**\n * Check for element dependencies (select-based, checkbox-based, radio-based).\n *\n * This is the main dependency analysis function that orchestrates the detection of\n * relationships between form elements. It identifies when elements are controlled by\n * other elements (e.g., select values determining field visibility).\n *\n * @param {HTMLElement} element - The element to check for dependencies\n * @returns {Array|null} Array of dependency objects or null if no dependencies found\n */\nconst checkElementDependencies = (element) => {\n    const form = element.closest('form');\n    if (!form) {\n        return null;\n    }\n\n    const elementContainer = element.closest('.fitem');\n    const dependencies = [];\n\n    // Analyze the visibility status of the current element.\n    const visibility = getElementVisibility(element, elementContainer);\n\n    // Find all potential controlling elements within the same form.\n    const controllingElements = form.querySelectorAll('select, input[type=\"checkbox\"], input[type=\"radio\"]');\n\n    controllingElements.forEach((controlElement) => {\n        // Skip self-references and inactive controlling elements.\n        if (controlElement === element ||\n            controlElement.closest('[style*=\"display: none\"]') ||\n            controlElement.hasAttribute('disabled') ||\n            controlElement.disabled) {\n            return;\n        }\n\n        // Analyze the relationship between the current element and potential controller.\n        const dependency = analyzeElementDependency(element, controlElement, visibility);\n        if (dependency) {\n            dependencies.push(dependency);\n        }\n    });\n\n    return dependencies.length > 0 ? dependencies : null;\n};\n\n/**\n * Get element visibility status.\n *\n * Analyzes how an element is hidden or disabled, providing detailed information\n * about the method used to hide the element. This is crucial for understanding\n * dependency relationships.\n *\n * @param {HTMLElement} element - The element to check\n * @param {HTMLElement} container - The container element (.fitem)\n * @returns {Object} Visibility information including hide method and disabled state\n */\nconst getElementVisibility = (element, container) => {\n    let isHidden = false;\n    let hideMethod = 'none';\n\n    if (container) {\n        const style = container.style;\n        const hiddenAttr = container.hasAttribute('hidden');\n        const computedStyle = window.getComputedStyle(container);\n\n        // Check various methods of hiding elements.\n        if (style && style.display === 'none') {\n            isHidden = true;\n            hideMethod = 'style_display';\n        } else if (hiddenAttr) {\n            isHidden = true;\n            hideMethod = 'hidden_attribute';\n        } else if (computedStyle.display === 'none') {\n            isHidden = true;\n            hideMethod = 'computed_style';\n        } else if (computedStyle.visibility === 'hidden') {\n            isHidden = true;\n            hideMethod = 'visibility_hidden';\n        }\n    }\n\n    return {\n        isHidden: isHidden,\n        hideMethod: hideMethod,\n        isDisabled: element.disabled || element.hasAttribute('disabled')\n    };\n};\n\n/**\n * Analyze potential dependency between two elements.\n *\n * This function implements the core logic for detecting dependencies between elements\n * using multiple pattern recognition strategies. It examines naming conventions,\n * container relationships, and semantic associations.\n *\n * @param {HTMLElement} dependentElement - The potentially dependent element\n * @param {HTMLElement} controlElement - The potentially controlling element\n * @param {Object} visibility - Visibility status of dependent element\n * @returns {Object|null} Dependency object or null if no relationship is found\n */\nconst analyzeElementDependency = (dependentElement, controlElement, visibility) => {\n    const controlName = controlElement.name || '';\n    const controlType = controlElement.type || controlElement.tagName.toLowerCase();\n    const controlValue = getControlElementValue(controlElement);\n\n    const dependentName = dependentElement.name || '';\n    const dependentId = dependentElement.id || '';\n\n    // Apply multiple pattern recognition strategies to identify dependencies.\n\n    // Pattern 1: Numeric suffix dependencies (e.g., primer1, instructions1 depend on preset=1).\n    const numericDependency = checkNumericSuffixDependency(dependentName, dependentId, controlName, controlValue);\n    if (numericDependency) {\n        return createDependencyObject(controlElement, controlValue, numericDependency.requiredValue, visibility);\n    }\n\n    // Pattern 2: Semantic name dependencies (mode -> topic/story/activities).\n    const semanticDependency = checkSemanticDependency(dependentName, dependentId, controlName, controlValue);\n    if (semanticDependency) {\n        return createDependencyObject(controlElement, controlValue, semanticDependency.requiredValue, visibility);\n    }\n\n    // Pattern 3: Container-based dependencies using data attributes.\n    const containerDependency = checkContainerDependency(dependentElement, controlElement, controlValue);\n    if (containerDependency) {\n        return createDependencyObject(controlElement, controlValue, containerDependency.requiredValue, visibility);\n    }\n\n    // Pattern 4: Checkbox enable/disable dependencies.\n    const enableDependency = checkEnableDependency(dependentName, dependentId, controlName, controlValue, controlType);\n    if (enableDependency) {\n        return createDependencyObject(controlElement, controlValue, enableDependency.requiredValue, visibility);\n    }\n\n    return null;\n};\n\n/**\n * Check for numeric suffix dependencies (e.g., primer1, instructions1 depend on preset=1).\n *\n * This pattern recognition function identifies dependencies where elements with numeric\n * suffixes depend on select/radio values. Common in scenarios like question presets\n * where different numbered configurations are shown based on selection.\n *\n * @param {string} dependentName - Name of dependent element\n * @param {string} dependentId - ID of dependent element\n * @param {string} controlName - Name of control element\n * @param {string} controlValue - Value of control element\n * @returns {Object|null} Dependency info or null if no pattern matches\n */\nconst checkNumericSuffixDependency = (dependentName, dependentId, controlName, controlValue) => {\n    // Extract numeric suffix from dependent element name or ID.\n    const dependentMatch = dependentName.match(/^(.+?)(\\d+)$/) || dependentId.match(/^id_(.+?)(\\d+)$/);\n    if (!dependentMatch) {\n        return null;\n    }\n\n    const baseName = dependentMatch[1];\n    const number = dependentMatch[2];\n\n    // Normalize control element name for comparison.\n    const controlBaseName = controlName.replace(/^(id_)?/, '').replace(/_$/, '');\n\n    // Define common patterns for numeric dependencies in Moodle forms.\n    const commonPatterns = [\n        {control: 'preset', dependents: ['primer', 'instructions', 'example', 'template', 'config']},\n        {control: 'mode', dependents: ['option', 'setting', 'param', 'field']},\n        {control: 'type', dependents: ['config', 'option', 'param', 'setting']},\n        {control: 'category', dependents: ['subcategory', 'item', 'field']},\n        {control: 'level', dependents: ['detail', 'item', 'option']}\n    ];\n\n    // Check if the control and dependent names match any known patterns.\n    for (let i = 0; i < commonPatterns.length; i++) {\n        const pattern = commonPatterns[i];\n        if (controlBaseName === pattern.control && pattern.dependents.indexOf(baseName) !== -1) {\n            // The dependency exists if the number matches the control value.\n            if (number === controlValue) {\n                return {requiredValue: controlValue};\n            }\n        }\n    }\n\n    return null;\n};\n\n/**\n * Check for semantic name dependencies.\n *\n * This function identifies dependencies based on semantic relationships between\n * element names, where certain fields are shown/hidden based on mode selections\n * or similar conceptual groupings.\n *\n * @param {string} dependentName - Name of dependent element\n * @param {string} dependentId - ID of dependent element\n * @param {string} controlName - Name of control element\n * @param {string} controlValue - Value of control element\n * @returns {Object|null} Dependency info or null if no semantic relationship found\n */\nconst checkSemanticDependency = (dependentName, dependentId, controlName, controlValue) => {\n    // Define semantic mappings between control values and dependent field names.\n    const semanticMappings = {\n        'mode': {\n            '1': ['topic', 'subject', 'theme'],\n            '2': ['content', 'story', 'text', 'material'],\n            '3': ['activities', 'courseactivities', 'course_content', 'modules']\n        },\n        'type': {\n            'manual': ['manual_config', 'manual_settings'],\n            'auto': ['auto_config', 'auto_settings'],\n            'custom': ['custom_config', 'custom_settings']\n        },\n        'format': {\n            'html': ['html_editor', 'wysiwyg'],\n            'plain': ['plain_text', 'textarea'],\n            'markdown': ['markdown_editor']\n        }\n    };\n\n    const controlBaseName = controlName.replace(/^(id_)?/, '');\n    const dependentBaseName = dependentName.replace(/^(id_)?/, '');\n\n    // Check if the control element and dependent element match semantic patterns.\n    if (semanticMappings[controlBaseName]) {\n        const valueMapping = semanticMappings[controlBaseName][controlValue];\n        if (valueMapping && valueMapping.indexOf(dependentBaseName) !== -1) {\n            return {requiredValue: controlValue};\n        }\n    }\n\n    return null;\n};\n\n/**\n * Check for container-based dependencies using data attributes.\n *\n * This function looks for explicit dependency declarations in HTML data attributes,\n * which provide a standardized way to declare element relationships in forms.\n *\n * @param {HTMLElement} dependentElement - The dependent element\n * @param {HTMLElement} controlElement - The control element\n * @param {string} controlValue - Value of control element\n * @returns {Object|null} Dependency info or null if no data attributes found\n */\nconst checkContainerDependency = (dependentElement, controlElement, controlValue) => {\n    const container = dependentElement.closest('.fitem');\n    if (!container) {\n        return null;\n    }\n\n    // Check for data-depends-on attribute pointing to the control element.\n    const dependsOn = container.getAttribute('data-depends-on');\n    if (dependsOn === controlElement.name || dependsOn === controlElement.id) {\n        const showWhen = container.getAttribute('data-show-when') || controlValue;\n        return {requiredValue: showWhen};\n    }\n\n    // Check for data-conditional attribute with JSON configuration.\n    const conditional = container.getAttribute('data-conditional');\n    if (conditional) {\n        try {\n            const conditionObj = JSON.parse(conditional);\n            if (conditionObj.element === controlElement.name && conditionObj.value === controlValue) {\n                return {requiredValue: controlValue};\n            }\n        } catch (e) {\n            // Silently ignore JSON parse errors to prevent script breaking.\n        }\n    }\n\n    return null;\n};\n\n/**\n * Check for enable/disable checkbox dependencies.\n *\n * Identifies checkboxes that control the enabled/disabled state of other form elements.\n * This is different from visibility dependencies and focuses on form interaction state.\n *\n * @param {string} dependentName - Name of dependent element\n * @param {string} dependentId - ID of dependent element\n * @param {string} controlName - Name of control element\n * @param {string} controlValue - Value of control element\n * @param {string} controlType - Type of control element\n * @returns {Object|null} Dependency info or null if no enable pattern matches\n */\nconst checkEnableDependency = (dependentName, dependentId, controlName, controlValue, controlType) => {\n    if (controlType !== 'checkbox') {\n        return null;\n    }\n\n    // Define common patterns for enable/disable checkbox naming.\n    const patterns = [\n        dependentName + '_enabled',\n        dependentName + '_enable',\n        'enable_' + dependentName,\n        dependentName.replace(/^id_/, '') + '_enabled'\n    ];\n\n    if (patterns.indexOf(controlName) !== -1) {\n        return {requiredValue: '1'};\n    }\n\n    return null;\n};\n\n/**\n * Get value from control element (select, checkbox, radio).\n *\n * Extracts the current value from different types of form controls,\n * handling the specifics of each input type appropriately.\n *\n * @param {HTMLElement} element - The control element\n * @returns {string} The current value as a string\n */\nconst getControlElementValue = (element) => {\n    const type = element.type || element.tagName.toLowerCase();\n\n    if (type === 'checkbox' || type === 'radio') {\n        // For checkboxes and radios, return '1' if checked, '0' if unchecked.\n        return element.checked ? '1' : '0';\n    } else if (type === 'select' || type === 'select-one' || type === 'select-multiple') {\n        // For select elements, return the selected value.\n        return element.value || '';\n    } else {\n        // For all other input types, return the value directly.\n        return element.value || '';\n    }\n};\n\n/**\n * Create standardized dependency object.\n *\n * This function creates a consistent structure for dependency information\n * that can be used by AI systems to understand form element relationships.\n *\n * @param {HTMLElement} controlElement - The controlling element\n * @param {string} controlValue - Current value of controlling element\n * @param {string} requiredValue - Required value for visibility/enablement\n * @param {Object} visibility - Visibility status object\n * @returns {Object} Standardized dependency object\n */\nconst createDependencyObject = (controlElement, controlValue, requiredValue, visibility) => {\n    return {\n        controllingElement: controlElement.name || '',\n        controllingElementId: controlElement.id || '',\n        controllingType: controlElement.type || controlElement.tagName.toLowerCase(),\n        controllingValue: controlValue,\n        requiredValue: requiredValue,\n        isCurrentlyVisible: !visibility.isHidden && controlValue === requiredValue,\n        hideMethod: visibility.hideMethod\n    };\n};\n\n/**\n * Enhanced dependency analysis that also checks for common JavaScript patterns.\n *\n * This function analyzes CSS classes and JavaScript event handlers to identify\n * additional dependency patterns that may not be captured by DOM structure alone.\n *\n * @param {HTMLElement} element - The element to analyze\n * @returns {Array|null} Array of JavaScript dependency objects or null\n */\nconst analyzeJavaScriptDependencies = (element) => {\n    const container = element.closest('.fitem');\n    if (!container) {\n        return null;\n    }\n\n    const dependencies = [];\n\n    // Analyze CSS classes that indicate dependencies.\n    const classes = container.className.split(' ');\n    classes.forEach((cls) => {\n        // Pattern: depends-on-fieldname, show-when-fieldname-value.\n        if (cls.startsWith('depends-on-')) {\n            const dependencyName = cls.replace('depends-on-', '');\n            dependencies.push({\n                type: 'css_class',\n                pattern: cls,\n                dependsOn: dependencyName\n            });\n        } else if (cls.match(/^show-when-\\w+-\\w+$/)) {\n            const parts = cls.replace('show-when-', '').split('-');\n            if (parts.length >= 2) {\n                dependencies.push({\n                    type: 'css_class',\n                    pattern: cls,\n                    dependsOn: parts[0],\n                    requiredValue: parts.slice(1).join('-')\n                });\n            }\n        }\n    });\n\n    // Prüfe Event-Handler, die auf Änderungen reagieren\n    const form = element.closest('form');\n    if (form) {\n        const scripts = document.querySelectorAll('script');\n        scripts.forEach((script) => {\n            const content = script.textContent || script.innerText;\n            if (content && content.includes(element.name || element.id)) {\n                // Suche nach Event-Handler-Patterns\n                const eventPatterns = [\n                    /addEventListener\\(['\"]change['\"],\\s*function/g,\n                    /\\.on\\(['\"]change['\"],\\s*function/g,\n                    /onchange\\s*=\\s*['\"]?[^'\"]+/g\n                ];\n\n                eventPatterns.forEach((pattern) => {\n                    if (content.match(pattern)) {\n                        dependencies.push({\n                            type: 'javascript_event',\n                            pattern: 'change_listener',\n                            element: element.name || element.id\n                        });\n                    }\n                });\n            }\n        });\n    }\n\n    return dependencies.length > 0 ? dependencies : null;\n};\n\n/**\n * Analyze sibling and parent-child dependencies within form groups.\n *\n * @param {HTMLElement} element - The element to analyze\n * @returns {Object|null} Sibling dependency information\n */\nconst analyzeSiblingDependencies = (element) => {\n    const container = element.closest('.fitem');\n    if (!container) {\n        return null;\n    }\n\n    const dependencies = [];\n    const elementName = element.name || '';\n\n    // Finde Geschwister-Container\n    const siblingContainers = [];\n    const parent = container.parentNode;\n    if (parent) {\n        const allFitems = parent.querySelectorAll('.fitem');\n        allFitems.forEach((fitem) => {\n            if (fitem !== container) {\n                siblingContainers.push(fitem);\n            }\n        });\n    }\n\n    // Analysiere Geschwister auf ähnliche Namen\n    siblingContainers.forEach((siblingContainer) => {\n        const siblingElements = siblingContainer.querySelectorAll('input, select, textarea');\n        siblingElements.forEach((siblingElement) => {\n            const siblingName = siblingElement.name || '';\n\n            // Pattern: Ähnliche Namen mit Suffixen/Präfixen\n            const similarity = analyzeSimilarity(elementName, siblingName);\n            if (similarity.score > 0.7 && similarity.type) {\n                const siblingVisibility = getElementVisibility(siblingElement, siblingContainer);\n\n                dependencies.push({\n                    type: 'sibling_dependency',\n                    siblingElement: siblingName,\n                    siblingId: siblingElement.id || '',\n                    similarity: similarity,\n                    siblingVisible: !siblingVisibility.isHidden\n                });\n            }\n        });\n    });\n\n    return dependencies.length > 0 ? dependencies : null;\n};\n\n/**\n * Analyze similarity between two element names.\n *\n * @param {string} name1 - First element name\n * @param {string} name2 - Second element name\n * @returns {Object} Similarity analysis\n */\nconst analyzeSimilarity = (name1, name2) => {\n    if (!name1 || !name2) {\n        return {score: 0, type: null};\n    }\n\n    // Entferne gemeinsame Präfixe\n    const cleanName1 = name1.replace(/^(id_)?/, '');\n    const cleanName2 = name2.replace(/^(id_)?/, '');\n\n    // Pattern 1: Numerische Suffixe (field1, field2, field3)\n    const numPattern1 = cleanName1.match(/^(.+?)(\\d+)$/);\n    const numPattern2 = cleanName2.match(/^(.+?)(\\d+)$/);\n\n    if (numPattern1 && numPattern2 && numPattern1[1] === numPattern2[1]) {\n        return {\n            score: 0.9,\n            type: 'numeric_series',\n            basePattern: numPattern1[1],\n            numbers: [numPattern1[2], numPattern2[2]]\n        };\n    }\n\n    // Pattern 2: Ähnliche Basis mit verschiedenen Suffixen\n    let commonPrefixLength = 0;\n    for (let i = 0; i < Math.min(cleanName1.length, cleanName2.length); i++) {\n        if (cleanName1[i] === cleanName2[i]) {\n            commonPrefixLength++;\n        } else {\n            break;\n        }\n    }\n\n    if (commonPrefixLength >= 3) {\n        const similarity = commonPrefixLength / Math.max(cleanName1.length, cleanName2.length);\n        return {\n            score: similarity,\n            type: 'similar_prefix',\n            commonPrefix: cleanName1.substring(0, commonPrefixLength)\n        };\n    }\n\n    return {score: 0, type: null};\n};\n\n/**\n * Determine visual visibility of an element based on computed styles.\n *\n * This function analyzes the computed CSS styles to determine if an element\n * is visually visible to the user. It checks multiple CSS properties that\n * can affect visibility including display, visibility, opacity, and dimensions.\n * It also traverses up the DOM tree to check if any parent elements are hidden.\n *\n * @param {HTMLElement} element - The element to check for visual visibility\n * @param {CSSStyleDeclaration} computedStyle - Optional pre-computed style object\n * @returns {boolean} True if the element is visually visible, false otherwise\n */\nconst getElementVisualVisibility = (element, computedStyle) => {\n    // First check if the element itself is hidden by any method.\n    if (!isElementDirectlyVisible(element, computedStyle)) {\n        return false;\n    }\n\n    // Then check if any parent element is hidden.\n    return !hasHiddenParent(element);\n};\n\n/**\n * Check if an element is directly visible (ignoring parent visibility).\n *\n * @param {HTMLElement} element - The element to check\n * @param {CSSStyleDeclaration} computedStyle - Optional pre-computed style object\n * @returns {boolean} True if the element itself is visible\n */\nconst isElementDirectlyVisible = (element, computedStyle) => {\n    // Check for hidden attribute.\n    if (element.hasAttribute('hidden')) {\n        return false;\n    }\n\n    // Use provided computed style or calculate it.\n    const styles = computedStyle || window.getComputedStyle(element);\n\n    // Check if element is hidden via display property.\n    if (styles.display === 'none') {\n        return false;\n    }\n\n    // Check if element is hidden via visibility property.\n    if (styles.visibility === 'hidden') {\n        return false;\n    }\n\n    // Check if element has zero dimensions (width or height).\n    const width = parseFloat(styles.width);\n    const height = parseFloat(styles.height);\n    if (width === 0 && height === 0) {\n        return false;\n    }\n\n    return true;\n};\n\n/**\n * Check if any parent element is hidden.\n *\n * Since we now wait for all JavaScript to execute before analyzing the DOM,\n * we can rely on the current computed styles to accurately reflect visibility.\n *\n * @param {HTMLElement} element - The element whose parents to check\n * @returns {boolean} True if any parent is hidden, false otherwise\n */\nconst hasHiddenParent = (element) => {\n    let parent = element.parentElement;\n\n    while (parent && parent !== document.body && parent !== document.documentElement) {\n        // Check for hidden attribute on parent elements.\n        if (parent.hasAttribute('hidden') || parent.hidden === true) {\n            return true;\n        }\n\n        // Check computed styles of parent elements.\n        const parentStyles = window.getComputedStyle(parent);\n        if (parentStyles.display === 'none' || parentStyles.visibility === 'hidden') {\n            return true;\n        }\n\n        parent = parent.parentElement;\n    }\n\n    return false;\n};\n"],"names":["elements","contentDiv","document","getElementById","querySelectorAll","forEach","node","type","tagName","toLowerCase","currentValue","options","checked","value","style","display","id","tinyFrame","querySelector","contentDocument","tinyBody","body","textContent","innerText","e","selectedOptions","length","isWithinDateTimeContainer","option","push","text","selected","label","findLabelForElement","helptext","findHelptextForElement","errorText","findErrorForElement","active","isDisabled","dependsOnEnabled","disabled","attrNode","getAttributeNode","_node$getAttributeNod","specified","computedStyle","window","getComputedStyle","isVisuallyVisible","getElementVisualVisibility","enabledDependency","checkEnabledDependency","checkboxName","isEnabled","allDependencies","checkElementDependencies","jsDependencies","analyzeJavaScriptDependencies","siblingDependencies","analyzeSiblingDependencies","elementData","name","visible","errorMessage","dependencies","pageContextElements","extractPageContext","contextElements","heading","helpButton","getAttribute","headingText","headingClone","cloneNode","helpButtonClone","remove","trim","getHeadingText","rawHelp","helpText","tmpDiv","createElement","innerHTML","contextElement","element","labelElement","parentLabel","closest","fitemDiv","labelDiv","searchContainers","parentElement","container","helpAnchor","errorDiv","errorSpan","ariaErrorId","ariaErrorElement","elementName","patterns","replace","nameParts","split","i","baseName","slice","join","enabledName","enabledCheckbox","checkboxId","fitemContainer","match","groupCheckboxes","gc","groupCheckbox","indexOf","form","elementContainer","visibility","getElementVisibility","controlElement","hasAttribute","dependency","analyzeElementDependency","isHidden","hideMethod","hiddenAttr","dependentElement","controlName","controlType","controlValue","getControlElementValue","dependentName","dependentId","numericDependency","checkNumericSuffixDependency","createDependencyObject","requiredValue","semanticDependency","checkSemanticDependency","containerDependency","checkContainerDependency","enableDependency","checkEnableDependency","dependentMatch","number","controlBaseName","commonPatterns","control","dependents","pattern","semanticMappings","dependentBaseName","valueMapping","dependsOn","conditional","conditionObj","JSON","parse","controllingElement","controllingElementId","controllingType","controllingValue","isCurrentlyVisible","className","cls","startsWith","dependencyName","parts","script","content","includes","siblingContainers","parent","parentNode","fitem","siblingContainer","siblingElement","siblingName","similarity","analyzeSimilarity","score","siblingVisibility","siblingId","siblingVisible","name1","name2","cleanName1","cleanName2","numPattern1","numPattern2","basePattern","numbers","commonPrefixLength","Math","min","max","commonPrefix","substring","isElementDirectlyVisible","hasHiddenParent","styles","width","parseFloat","height","documentElement","hidden","parentStyles"],"mappings":"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"}