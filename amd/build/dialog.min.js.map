{"version":3,"file":"dialog.min.js","sources":["../src/dialog.js"],"sourcesContent":["import DialogModal from 'block_ai_interface/dialog_modal';\nimport * as externalServices from 'block_ai_interface/webservices';\nimport Templates from 'core/templates';\nimport {exception as displayException} from 'core/notification';\nimport {makeRequest} from 'local_ai_manager/make_request';\nimport { getNewConversationId } from './webservices';\n\n// Declare variables.\n// Modal.\nlet modal = {};\nlet modaltitle = '';\n\n// Current conversation.\nlet conversation = {\n    id: 0,\n    messages: [],\n};\n// All conversations.\nlet allConversations = [];\n// Userid.\nlet userid = 0;\n// Course context id.\nlet contextid = 0;\n// First load.\nlet firstLoad = true;\n// AI in process of answering.\nlet aiAtWork = false;\n\nexport const init = async(params) => {\n    userid = params.userid;\n    contextid = params.contextid;\n    modaltitle = params.title;\n\n    // Build modal.\n    modal = await DialogModal.create({\n        templateContext: {\n            title: modaltitle,\n            // history: history, // history dynamically added.\n        },\n    });\n\n    // Add class for styling when modal is displayed.\n    modal.getRoot().on('modal:shown', function(e) {\n        e.target.classList.add(\"ai_interface_modal\");\n    });\n\n    // Load conversations.\n    await getConversations();\n\n    // Attach listener to the ai button to call modal.\n    let button = document.getElementById(\"ai_interface_button\");\n    button.addEventListener('mousedown', function() {\n        showModal(params);\n    });\n};\n\n/**\n * Show ai_interface modal.\n */\nasync function showModal() {\n\n    // Show modal.\n    await modal.show();\n\n    // Add listener for input submission.\n    const form = document.getElementById('block_ai_form');\n    form.addEventListener(\"submit\", (event) => {\n        submitForm(event);\n    });\n    const textarea = document.getElementById('block_ai_interface-input-id');\n    addTextareaListener(textarea);\n\n\n    if (firstLoad) {\n        // Show conversation.\n        // Todo - Evtl. noch firstload verschönern, spinner für header und content z.b.\n        showConversation();\n\n        // Add history to dropdownmenu.\n        addToHistory(allConversations);\n\n        // Add listeners for dropdownmenu.\n        const btnNewDialog = document.getElementById('block_ai_interface_new_dialog');\n        btnNewDialog.addEventListener('mousedown', () => {\n            newDialog();\n        });\n        const btnDeleteDialog = document.getElementById('block_ai_interface_delete_dialog');\n        btnDeleteDialog.addEventListener('click', () => {\n            deleteCurrentDialog();\n        });\n        firstLoad = false;\n    }\n\n    focustextarea();\n}\n\n/**\n * Send input to ai connector.\n * @param {*} question\n */\nconst enterQuestion = async(question) => {\n\n    // Deny changing dialogs until answer present?\n\n    // Add to conversation, answer not yet available.\n    showMessage(question, 'self', false);\n\n    // For first message, add a system message.\n    if (conversation.messages.length === 0) {\n        conversation.messages.push({\n            'message': 'Answer in german',\n            'sender': 'system',\n        });\n    }\n\n    // Options, with conversation history.\n    const options = {\n        'component': 'block_ai_interface',\n        'contextid': contextid,\n        'conversationcontext': conversation.messages,\n    };\n\n    // For a new conversation, get an id.\n    if (conversation.id === 0) {\n        try {\n            let idresult = await externalServices.getNewConversationId(contextid);\n            conversation.id = idresult.id;\n        } catch (error) {\n            displayException(error);\n        }\n        options.forcenewitemid = true;\n    }\n    options.itemid = conversation.id;\n\n\n    // Send to local_ai_manager.\n    let requestresult = await askLocalAiManager('chat', question, options);\n    // If code 409, conversationid is already taken, get new one.\n    while (requestresult.code == 409) {\n        // Todo test, sleep and falsify db entry so error is triggered and a new id is given.\n        try {\n            let idresult = await externalServices.getNewConversationId(contextid);\n            conversation.id = idresult.id;\n            options.itemid = conversation.id;\n        } catch (error) {\n            displayException(error);\n        }\n        // Retry with new id.\n        requestresult = await askLocalAiManager('chat', question, options);\n    }\n\n    // Write back answer.\n    showReply(requestresult.result);\n\n    // Attach copy listener.\n    let copy = document.querySelector('.ai_interface_modal .awaitanswer .copy');\n    copyToClipboard(copy);\n\n    // Save new question and answer.\n    saveConversationLocally(question, requestresult.result);\n\n    // Ai is done.\n    aiAtWork = false;\n};\n\n/**\n * Render reply.\n * @param {string} text\n */\nconst showReply = (text) => {\n    let field = document.querySelector('.ai_interface_modal .awaitanswer .text div');\n    field.replaceWith(text);\n};\n\n/**\n * Create new / Reset dialog.\n * @param {bool} deleted\n */\nconst newDialog = (deleted = false) => {\n    console.log(\"newDialog called\");\n    // Add current convo to history and local representation, if not already there.\n    if (allConversations.find(x => x.id === conversation.id) === undefined && !deleted) {\n        addToHistory([conversation]);\n        allConversations.push(conversation);\n    }\n    // Reset local conservation.\n    conversation = {\n        id: 0,\n        messages: [],\n    };\n    clearMessages();\n    setModalHeader(true);\n};\n\n/**\n * Delete /hide current dialog.\n */\nconst deleteCurrentDialog = async() => {\n    console.log(\"deleteCurrentDialog called\");\n    if (conversation.id !== 0) {\n        try {\n            const deleted = await externalServices.deleteConversation(contextid, userid, conversation.id);\n            if (deleted) {\n                removeFromHistory();\n                showConversation();\n                // newDialog(true);\n            }\n        } catch (error) {\n            displayException(error);\n        }\n    }\n};\n\n/**\n * Get the async answer from the local_ai_manager.\n *\n * @param {string} purpose\n * @param {string} prompt\n * @param {array} options\n * @returns {string}\n */\nconst askLocalAiManager = async(purpose, prompt, options = []) => {\n    let result;\n    try {\n        result = await makeRequest(purpose, prompt, JSON.stringify(options));\n    } catch (error) {\n        displayException(error);\n    }\n    return result;\n};\n\nconst showMessages = () => {\n    console.log(\"showMessages called\");\n    conversation.messages.forEach((val) => {\n        showMessage(val.message, val.sender);\n    });\n};\n\n/**\n * Show answer from local_ai_manager.\n * @param {*} text\n * @param {*} sender User or Ai\n * @param {*} answer Is answer in history\n */\nconst showMessage = async(text, sender = '', answer = true) => {\n    // Skip if sender is system.\n    if (sender === 'system') {\n        return;\n    }\n    // Imitate bool for message.mustache logic {{#sender}}.\n    if (sender === 'ai') {\n        sender = '';\n    }\n    const templateData = {\n        \"sender\": sender,\n        \"content\": text,\n        \"answer\": answer,\n    };\n    // Call the function to load and render our template.\n    const {html, js} = await Templates.renderForPromise('block_ai_interface/message', templateData);\n    Templates.appendNodeContents('.block_ai_interface-output', html, js);\n\n    // Scroll the modal content to the bottom.\n    scrollToBottom();\n};\n\n/**\n * Clear output div.\n */\nconst clearMessages = () => {\n    console.log(\"clearMessages called\");\n    const output = document.querySelector('.block_ai_interface-output');\n    output.innerHTML = '';\n};\n\n/**\n * Webservice Get all conversations.\n */\nconst getConversations = async() => {\n    console.log(\"allConversations called\");\n    try {\n        // Ist hier await nötig um in init auf den Button listener zu warten?\n        allConversations = await externalServices.getAllConversations(userid, contextid);\n    } catch (error) {\n        displayException(error);\n    }\n};\n\n/**\n * Add conversations to history.\n * @param {*} convos Conversations\n */\nconst addToHistory = (convos) => {\n    convos.forEach(async(convo) => {\n        // Conditionally shorten menu title, skip system message.\n        let title = convo.messages[1].message;\n        if (convo.messages[1].message.length > 50) {\n            title = convo.messages[1].message.substring(0, 50);\n            title += ' ...';\n        }\n\n        // Add entry in menu.\n        const templateData = {\n            \"title\": title,\n            \"conversationid\": convo.id,\n        };\n\n        const {html, js} = await Templates.renderForPromise('block_ai_interface/dropdownmenuitem', templateData);\n        Templates.appendNodeContents('.block_ai_interface_action_menu .dropdown-menu', html, js);\n\n        // If we add only one item, it is a new item and should be on top of history.\n        if (convos.length === 1) {\n            console.log(\"move item to top called\");\n            // Make sure elements are in place to be worked with.\n            const dropdown = document.querySelector('.block_ai_interface_action_menu .dropdown-menu');\n            // Select the last element.\n            const lastItem = dropdown.lastElementChild;\n            // Get the reference element for the third position.\n            const thirdChild = dropdown.children[2];\n            // Remove the last item from its current position.\n            dropdown.removeChild(lastItem);\n            // Insert the last item at the new position (before the third child).\n            dropdown.insertBefore(lastItem, thirdChild);                \n        }\n    });\n\n    // If we have more than 9 items, add scrollbar to menu.\n    if (convos.length > 9) {\n        const dropdown = document.querySelector('.block_ai_interface_action_menu .dropdown-menu');\n        dropdown.classList.add(\"addscroll\");\n    }\n};\n\n/**\n * Remove currrent conversation from history.\n */\nconst removeFromHistory = () => {\n    if (conversation.id !== 0) {\n        // Remove from dropdown.\n        const element = document.querySelector('.block_ai_interface_action_menu [data-id=\"' + conversation.id + '\"]');\n        element.remove();\n        // Remove from allConversations array.\n        allConversations = allConversations.filter(obj => obj.id !== conversation.id);\n    }\n};\n\n/**\n * Function to set conversation.\n * @param {*} id\n */\nconst showConversation = (id = 0) => {\n    // Change conversation or get last conversation.\n    console.log(\"showConversation called\");\n    if (id !== 0) {\n        conversation = allConversations.find(x => x.id === id);\n    } else if (typeof allConversations[0] !== 'undefined') {\n        console.log(\"last item allconv\");\n        conversation = allConversations.at(0);\n    }\n    clearMessages();\n    showMessages();\n    setModalHeader();\n    attachCopyListener();\n};\n// Make globally accessible since it is used to show history in dropdownmenuitem.mustache.\ndocument.showConversation = showConversation;\n\n/**\n * Webservice Save conversation.\n * @param {*} question\n * @param {*} reply\n */\nconst saveConversationLocally = (question, reply) => {\n    // Add to local representation.\n    let message = {'message': question, 'sender': 'user'};\n    conversation.messages.push(message);\n    message = {'message': reply, 'sender': 'ai'};\n    conversation.messages.push(message);\n};\n\n/**\n * Set modal header title.\n * @param {*} empty\n */\nconst setModalHeader = (empty = false) => {\n    let modalheader = document.querySelector('.ai_interface_modal .modal-title div');\n    if (modalheader !== null && (conversation.messages.length > 0 || empty)) {\n        let title = '';\n        if (!empty) {\n            title = ' - ' + conversation.messages[1].message;\n            if (conversation.messages[1].message.length > 50) {\n                title = ' - ' + conversation.messages[1].message.substring(0, 50);\n                title += ' ...';\n            }\n        }\n        modalheader.innerHTML = modaltitle + title;\n    }\n};\n\n/**\n * Focus textarea.\n */\nconst focustextarea = () => {\n    const textarea = document.getElementById('block_ai_interface-input-id');\n    textarea.focus();\n};\n\n/**\n * Scroll to bottom of modal body.\n */\nconst scrollToBottom = () => {\n    console.log(\"scroll to bottom called\");\n    const modalContent = document.querySelector('.ai_interface_modal .modal-body');\n    modalContent.scrollTop = modalContent.scrollHeight;\n};\n\n/**\n * Attach event listener.\n * @param {*} textarea\n */\nconst addTextareaListener = (textarea) => {\n    textarea.addEventListener('keydown', textareaOnKeydown);\n};\n\n/**\n * Action for textarea submission.\n * @param {*} event\n */\nconst textareaOnKeydown = (event) => {\n    // TODO check for mobile devices.\n    if (event.key === 'Enter' && !aiAtWork && !event.shiftKey) {\n        aiAtWork = true;\n        enterQuestion(event.target.value);\n        event.preventDefault();\n        event.target.value = '';\n    }\n};\n\n/**\n * Submit form.\n * @param {*} event\n */\nconst submitForm = (event) => {\n    event.preventDefault();\n    // Var aiAtWork to make it impossible to submit multiple questions at once.\n    if (!aiAtWork) {\n        aiAtWork = true;\n        const textarea = document.getElementById('block_ai_interface-input-id');\n        enterQuestion(textarea.value);\n        textarea.value = '';\n    }\n};\n\n/**\n * Attach copy listener to all elements.\n */\nconst attachCopyListener = () => {\n    const elements = document.querySelectorAll(\".ai_interface_modal .copy\");\n    elements.forEach((element) => {\n        element.addEventListener('mousedown', function() {\n            copyToClipboard(element);\n        });\n    });\n}\n\n/**\n * Copy ai reply to clipboard.\n * @param {*} element\n */\nconst copyToClipboard = (element) => {\n\n    // Find the adjacent text container.\n    const textElement = element.nextElementSibling;\n\n    // Get the text content.\n    const textToCopy = textElement.innerText || textElement.textContent;\n\n    // Copy to clipboard using the Clipboard API.\n    navigator.clipboard.writeText(textToCopy);\n};\n"],"names":["modal","modaltitle","conversation","id","messages","allConversations","userid","contextid","firstLoad","aiAtWork","async","params","title","DialogModal","create","templateContext","getRoot","on","e","target","classList","add","getConversations","document","getElementById","addEventListener","show","event","submitForm","textarea","addTextareaListener","showConversation","addToHistory","newDialog","deleteCurrentDialog","focustextarea","showModal","enterQuestion","showMessage","question","length","push","options","idresult","externalServices","getNewConversationId","error","forcenewitemid","itemid","requestresult","askLocalAiManager","code","showReply","result","copy","querySelector","copyToClipboard","saveConversationLocally","text","replaceWith","deleted","console","log","undefined","find","x","clearMessages","setModalHeader","deleteConversation","removeFromHistory","purpose","prompt","JSON","stringify","showMessages","forEach","val","message","sender","answer","templateData","html","js","Templates","renderForPromise","appendNodeContents","scrollToBottom","innerHTML","getAllConversations","convos","convo","substring","dropdown","lastItem","lastElementChild","thirdChild","children","removeChild","insertBefore","remove","filter","obj","at","attachCopyListener","reply","empty","modalheader","focus","modalContent","scrollTop","scrollHeight","textareaOnKeydown","key","shiftKey","value","preventDefault","querySelectorAll","element","textElement","nextElementSibling","textToCopy","innerText","textContent","navigator","clipboard","writeText"],"mappings":"u/CASIA,MAAQ,GACRC,WAAa,GAGbC,aAAe,CACfC,GAAI,EACJC,SAAU,IAGVC,iBAAmB,GAEnBC,OAAS,EAETC,UAAY,EAEZC,WAAY,EAEZC,UAAW,gBAEKC,MAAAA,SAChBJ,OAASK,OAAOL,OAChBC,UAAYI,OAAOJ,UACnBN,WAAaU,OAAOC,MAGpBZ,YAAca,sBAAYC,OAAO,CAC7BC,gBAAiB,CACbH,MAAOX,cAMfD,MAAMgB,UAAUC,GAAG,eAAe,SAASC,GACvCA,EAAEC,OAAOC,UAAUC,IAAI,+BAIrBC,mBAGOC,SAASC,eAAe,uBAC9BC,iBAAiB,aAAa,mCAW/BzB,MAAM0B,OAGCH,SAASC,eAAe,iBAChCC,iBAAiB,UAAWE,QAC7BC,WAAWD,gBAETE,SAAWN,SAASC,eAAe,kCACzCM,oBAAoBD,UAGhBrB,UAAW,CAGXuB,mBAGAC,aAAa3B,kBAGQkB,SAASC,eAAe,iCAChCC,iBAAiB,aAAa,KACvCQ,eAEoBV,SAASC,eAAe,oCAChCC,iBAAiB,SAAS,KACtCS,yBAEJ1B,WAAY,EAGhB2B,gBAzCIC,aAgDFC,cAAgB3B,MAAAA,WAKlB4B,YAAYC,SAAU,QAAQ,GAGO,IAAjCrC,aAAaE,SAASoC,QACtBtC,aAAaE,SAASqC,KAAK,SACZ,0BACD,iBAKZC,QAAU,WACC,+BACAnC,8BACUL,aAAaE,aAIhB,IAApBF,aAAaC,GAAU,SAEfwC,eAAiBC,iBAAiBC,qBAAqBtC,WAC3DL,aAAaC,GAAKwC,SAASxC,GAC7B,MAAO2C,mCACYA,OAErBJ,QAAQK,gBAAiB,EAE7BL,QAAQM,OAAS9C,aAAaC,OAI1B8C,oBAAsBC,kBAAkB,OAAQX,SAAUG,cAEjC,KAAtBO,cAAcE,MAAa,SAGtBR,eAAiBC,iBAAiBC,qBAAqBtC,WAC3DL,aAAaC,GAAKwC,SAASxC,GAC3BuC,QAAQM,OAAS9C,aAAaC,GAChC,MAAO2C,mCACYA,OAGrBG,oBAAsBC,kBAAkB,OAAQX,SAAUG,SAI9DU,UAAUH,cAAcI,YAGpBC,KAAO/B,SAASgC,cAAc,0CAClCC,gBAAgBF,MAGhBG,wBAAwBlB,SAAUU,cAAcI,QAGhD5C,UAAW,GAOT2C,UAAaM,OACHnC,SAASgC,cAAc,8CAC7BI,YAAYD,OAOhBzB,UAAY,eAAC2B,gEACfC,QAAQC,IAAI,yBAEiDC,IAAzD1D,iBAAiB2D,MAAKC,GAAKA,EAAE9D,KAAOD,aAAaC,MAAsByD,UACvE5B,aAAa,CAAC9B,eACdG,iBAAiBoC,KAAKvC,eAG1BA,aAAe,CACXC,GAAI,EACJC,SAAU,IAEd8D,gBACAC,gBAAe,IAMbjC,oBAAsBxB,aACxBmD,QAAQC,IAAI,8BACY,IAApB5D,aAAaC,aAEayC,iBAAiBwB,mBAAmB7D,UAAWD,OAAQJ,aAAaC,MAEtFkE,oBACAtC,oBAGN,MAAOe,mCACYA,SAavBI,kBAAoBxC,eAAM4D,QAASC,YACjClB,OADyCX,+DAAU,OAGnDW,aAAe,6BAAYiB,QAASC,OAAQC,KAAKC,UAAU/B,UAC7D,MAAOI,mCACYA,cAEdO,QAGLqB,aAAe,KACjBb,QAAQC,IAAI,uBACZ5D,aAAaE,SAASuE,SAASC,MAC3BtC,YAAYsC,IAAIC,QAASD,IAAIE,YAU/BxC,YAAc5B,eAAMgD,UAAMoB,8DAAS,GAAIC,qEAE1B,WAAXD,cAIW,OAAXA,SACAA,OAAS,UAEPE,aAAe,QACPF,eACCpB,YACDqB,SAGRE,KAACA,KAADC,GAAOA,UAAYC,mBAAUC,iBAAiB,6BAA8BJ,iCACxEK,mBAAmB,6BAA8BJ,KAAMC,IAGjEI,kBAMEpB,cAAgB,KAClBL,QAAQC,IAAI,wBACGvC,SAASgC,cAAc,8BAC/BgC,UAAY,IAMjBjE,iBAAmBZ,UACrBmD,QAAQC,IAAI,+BAGRzD,uBAAyBuC,iBAAiB4C,oBAAoBlF,OAAQC,WACxE,MAAOuC,mCACYA,SAQnBd,aAAgByD,YAClBA,OAAOd,SAAQjE,MAAAA,YAEPE,MAAQ8E,MAAMtF,SAAS,GAAGyE,QAC1Ba,MAAMtF,SAAS,GAAGyE,QAAQrC,OAAS,KACnC5B,MAAQ8E,MAAMtF,SAAS,GAAGyE,QAAQc,UAAU,EAAG,IAC/C/E,OAAS,cAIPoE,aAAe,OACRpE,qBACS8E,MAAMvF,KAGtB8E,KAACA,KAADC,GAAOA,UAAYC,mBAAUC,iBAAiB,sCAAuCJ,oCACjFK,mBAAmB,iDAAkDJ,KAAMC,IAG/D,IAAlBO,OAAOjD,OAAc,CACrBqB,QAAQC,IAAI,iCAEN8B,SAAWrE,SAASgC,cAAc,kDAElCsC,SAAWD,SAASE,iBAEpBC,WAAaH,SAASI,SAAS,GAErCJ,SAASK,YAAYJ,UAErBD,SAASM,aAAaL,SAAUE,gBAKpCN,OAAOjD,OAAS,EAAG,CACFjB,SAASgC,cAAc,kDAC/BnC,UAAUC,IAAI,eAOzBgD,kBAAoB,QACE,IAApBnE,aAAaC,GAAU,CAEPoB,SAASgC,cAAc,6CAA+CrD,aAAaC,GAAK,MAChGgG,SAER9F,iBAAmBA,iBAAiB+F,QAAOC,KAAOA,IAAIlG,KAAOD,aAAaC,OAQ5E4B,iBAAmB,eAAC5B,0DAAK,EAE3B0D,QAAQC,IAAI,2BACD,IAAP3D,GACAD,aAAeG,iBAAiB2D,MAAKC,GAAKA,EAAE9D,KAAOA,UACb,IAAxBE,iBAAiB,KAC/BwD,QAAQC,IAAI,qBACZ5D,aAAeG,iBAAiBiG,GAAG,IAEvCpC,gBACAQ,eACAP,iBACAoC,sBAGJhF,SAASQ,iBAAmBA,uBAOtB0B,wBAA0B,CAAClB,SAAUiE,aAEnC3B,QAAU,SAAYtC,gBAAoB,QAC9CrC,aAAaE,SAASqC,KAAKoC,SAC3BA,QAAU,SAAY2B,aAAiB,MACvCtG,aAAaE,SAASqC,KAAKoC,UAOzBV,eAAiB,eAACsC,8DAChBC,YAAcnF,SAASgC,cAAc,2CACrB,OAAhBmD,cAAyBxG,aAAaE,SAASoC,OAAS,GAAKiE,OAAQ,KACjE7F,MAAQ,GACP6F,QACD7F,MAAQ,MAAQV,aAAaE,SAAS,GAAGyE,QACrC3E,aAAaE,SAAS,GAAGyE,QAAQrC,OAAS,KAC1C5B,MAAQ,MAAQV,aAAaE,SAAS,GAAGyE,QAAQc,UAAU,EAAG,IAC9D/E,OAAS,SAGjB8F,YAAYnB,UAAYtF,WAAaW,QAOvCuB,cAAgB,KACDZ,SAASC,eAAe,+BAChCmF,SAMPrB,eAAiB,KACnBzB,QAAQC,IAAI,iCACN8C,aAAerF,SAASgC,cAAc,mCAC5CqD,aAAaC,UAAYD,aAAaE,cAOpChF,oBAAuBD,WACzBA,SAASJ,iBAAiB,UAAWsF,oBAOnCA,kBAAqBpF,QAEL,UAAdA,MAAMqF,KAAoBvG,UAAakB,MAAMsF,WAC7CxG,UAAW,EACX4B,cAAcV,MAAMR,OAAO+F,OAC3BvF,MAAMwF,iBACNxF,MAAMR,OAAO+F,MAAQ,KAQvBtF,WAAcD,WAChBA,MAAMwF,kBAED1G,SAAU,CACXA,UAAW,QACLoB,SAAWN,SAASC,eAAe,+BACzCa,cAAcR,SAASqF,OACvBrF,SAASqF,MAAQ,KAOnBX,mBAAqB,KACNhF,SAAS6F,iBAAiB,6BAClCzC,SAAS0C,UACdA,QAAQ5F,iBAAiB,aAAa,WAClC+B,gBAAgB6D,gBAStB7D,gBAAmB6D,gBAGfC,YAAcD,QAAQE,mBAGtBC,WAAaF,YAAYG,WAAaH,YAAYI,YAGxDC,UAAUC,UAAUC,UAAUL"}